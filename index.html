<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Department Budget Allocation</title>
  <style>
    :root {
      --primary-color: #3f51b5;
      --secondary-color: #f5f5f5;
      --accent-color: #ff4081;
      --text-color: #333;
      --light-gray: #e0e0e0;
      --danger-color: #f44336;
      --danger-bg: #ffebee;
      --success-color: #4caf50;
    }

    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      margin: 0;
      padding: 20px;
      background-color: #f9f9f9;
      color: var(--text-color);
      min-width: 1400px;
      /* Prevent wrapping on small screens */
    }

    .container {
      max-width: 1500px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      overflow-x: auto;
      /* Allow horizontal scrolling */
    }

    h1 {
      color: var(--primary-color);
      margin-top: 0;
      margin-bottom: 20px;
      font-weight: 500;
    }

    .header-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--light-gray);
    }

    .filters select {
      padding: 8px 12px;
      border: 1px solid var(--light-gray);
      border-radius: 4px;
      margin-right: 10px;
      font-size: 14px;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #303f9f;
    }

    button:disabled {
      background-color: #9e9e9e;
      cursor: not-allowed;
    }

    button.danger {
    background-color: var(--danger-color);
    margin-top: auto;
    align-self: flex-end;
    width: 125px;
    height: 20px;
    padding: 0px;
    line-height: 1;
}

    button.save {
      background-color: var(--success-color);
    }

    button.danger:hover {
      background-color: #d32f2f;
    }

    button.save:hover {
      background-color: #45a049;
    }

    .tab-container {
      margin: 20px 0;
      border-bottom: 2px solid var(--light-gray);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #currency-display {
      font-size: 16px;
      padding: 10px;
      align-items: center;
      /* Vertically align items in the middle */
      justify-content: center;
      /* Horizontally align items in the middle (optional) */
    }

    .bold-currency {
      font-weight: bold;
    }

    #add-employee-btn {
      display: none;
      /* Hidden by default */
    }

    .tab-container.staff-active #add-employee-btn {
      display: block;
    }

    .tabs {
      display: flex;
      gap: 2px;
    }

    .tab {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      background-color: #999;
      border: none;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      min-width: 200px;
    }

    .tab.active {
      background-color: var(--primary-color);
      color: white;
    }

    .tab-content {
      display: none;
      padding: 20px 0;
    }

    .tab-content.active {
      display: block;
    }

    .employee-box {
      border-radius: 8px;
      margin-bottom: 5px;
      padding: 0px;
      background-color: f5f5f5;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
      transition: border-color 0.3s;
    }

    .employee-box.expanded {
      margin-top: 10px;
      padding: 10px; /* Add padding when expanded */
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
}
    .employee-box.error {
      border-color: var(--danger-color);
      background-color: var(--danger-bg);
    }

    .employee-allocations.error {
      border-color: var(--danger-color);
      background-color: var(--danger-bg);
    }


    /*
    .employee-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
*/
    .employee-info {
      display: grid;
      grid-template-columns: 25px 1fr 1fr 125px 150px 150px 150px 150px 150px 50px;
      /* Added one more column */
      gap: 5px;
      margin-bottom: 5px;
    }

    .employee-column-headers {
      display: grid;
      grid-template-columns: 25px 1fr 1fr 125px 150px 150px 150px 150px 150px 50px;
      gap: 5px;
      margin-bottom: 10px;
      font-weight: 500;
      font-size: 13px;
      color: #555;
      padding: 1 1px;
      width: 100%;
      /* Fixed width to prevent wrapping */
      justify-items: center;
      text-align: center;
    }

    .employee-info .field-group {
      display: flex;
      flex-direction: column;
      justify-items: center;
      text-align: center;
      align-items: center;
      /* Add this line */
      font-size: 14px;
      vertical-align: middle;
    }


    .field-group label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }

    .field-group input,
    .field-group select {
      padding: 3px;
      border: 1px solid var(--light-gray);
      border-radius: 4px;
      font-size: 13px;
      width: 100%;
    }

    .field-group input:disabled {
      background-color: var(--secondary-color);
      cursor: not-allowed;
    }

    .column-headers {
      display: grid;
      grid-template-columns: 30px 80px 250px 80px repeat(13, 65px);
      gap: 5px;
      margin-bottom: 10px;
      font-weight: 500;
      font-size: 13px;
      color: #555;
      padding: 1 1px;
      width: 100%;
      /* Fixed width to prevent wrapping */
      justify-items: center;
      text-align: center;
    }

    .column-headers button.add-line {
      width: 24px;
      height: 24px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      background-color: var(--primary-color);
      color: white;
    }

    .column-headers button.add-line:hover {
      background-color: #303f9f;
    }

    .allocation-line {
      display: grid;
      grid-template-columns: 30px 80px 250px 80px repeat(13, 65px);
      gap: 5px;
      margin-bottom: 1px;
      justify-items: center;
      text-align: center;
      padding: 1px 1px;
      border-radius: 4px;
      background-color: var(--secondary-color);
      width: 100%;
      /* Fixed width to prevent wrapping */
    }

    .expand-button {
      background: none;
      border: none;
      color: var(--primary-color);
      font-size: 16px;
      cursor: pointer;
      padding: 0 8px;
      width: 30px;
    }

    .expand-button:hover {
      color: var(--accent-color);
    }

    .employee-allocations {
      display: none;
      padding: 10px 30px;
      background-color: white;
    }

    .employee-allocations.expanded {
      display: block;
      margin-bottom: 10px; /* Add margin when expanded */
    }

    .delete-line {
      width: 24px;
      height: 24px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      background-color: transparent;
      color: #999;
      border: none;
      cursor: pointer;
    }

    .delete-line:hover {
      color: var(--danger-color);
    }

    .allocation-line button.delete-line {
      width: 24px;
      height: 24px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      background-color: transparent;
      color: #999;
    }


    .allocation-line button.delete-line:hover {
      color: var(--danger-color);
    }

    .allocation-line select,
    .allocation-line input {
      padding: 3px;
      border: 1px solid var(--light-gray);
      border-radius: 4px;
      font-size: 13px;
      width: 100%;
    }


    .grand-total-value div {
      grid-template-columns: 30px 80px 200px;
      font-size: 12px;
      font-weight: bold;
      text-decoration: underline;
      color: var(--text-color);
      background-color: var(--secondary-color);
      text-align: right;
      padding: 5px;
    }



    .grand-total-value div:last-child {
      font-weight: bold;
      padding-right: 10px;
    }


    .allocation-line input.monthly-input {
      text-align: right;
    }

    .justification-value {
      display: grid;
      grid-template-columns: 200px 1fr;
      /* Label and Input */
      align-items: center;
      margin-bottom: 5px;
      padding: 5px;
    }

    .justification-value label {
      text-align: right;
      padding-right: 10px;
      font-weight: bold;
    }

    .justification-value input {
      width: 100%;
      /* Make the input take up the remaining space */
      padding: 8px;
      border: 1px solid var(--light-gray);
      border-radius: 4px;
      font-size: 14px;
    }



    .total-value {
      font-size: 12px;
      font-weight: bold;
      color: var(--text-color);
      text-align: right;
      padding: 5px;
      border-radius: 4px;
      background-color: var(--secondary-color);
    }

    /*
    .allocation-actions {
      margin-top: 15px;
      display: flex;
      justify-content: flex-end;
    }
*/
    .error-message {
      color: var(--danger-color);
      font-size: 13px;
      margin-top: 10px;
    }

    .newemployee-bottom {
      text-align: right;
      padding-top: 20px;
    }

    .grand-total {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 2px solid var(--light-gray);
    }

    .grand-total-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .grand-total-row span:first-child {
      font-weight: 500;
    }

    .grand-total-row span:last-child {
      font-size: 18px;
      color: var(--primary-color);
    }

    .grand-final-total-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      border-top: 2px solid var(--primary-color);
      padding-top: 10px;
    }

    .grand-final-total-row span:first-child {
      font-weight: bold;
    }

    .grand-final-total-row span:last-child {
      font-size: 18px;
      color: var(--primary-color);
      font-weight: bold;
    }

    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 200px;
    }

    .error-text {
      color: var(--danger-color);
    }

    .save-section {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 2px solid var(--light-gray);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .save-info {
      color: #666;
      font-size: 14px;
    }

    .validation-summary {
      color: var(--danger-color);
      font-size: 14px;
      margin-right: 20px;
    }

    #flexible-expenses {
      display: flex;
      flex-direction: column;
    }

    .newexpense-bottom {
      text-align: right;
      margin-top: 20px;
    }

    #flexible-expenses .column-headers,
    #flexible-expenses .allocation-line {
      grid-template-columns: 10px minmax(200px, 1fr) 30px 75px 200px 100px repeat(12, 70px) 75px 75px;
    }

    /* Add class for when spend-to-date column is present */
    #flexible-expenses .column-headers.has-actuals,
    #flexible-expenses .allocation-line.has-actuals {
      grid-template-columns: 10px minmax(200px, 1fr) 30px 75px 200px 100px repeat(var(--actual-months, 12), 75px) 75px repeat(var(--remaining-months, 0), 70px) 75px;
    }

    #flexible-expenses .column-headers div {
      padding: 8px 0;
      /* Remove background-color from here */
    }


    #flexible-expenses .allocation-line:nth-child(even) {
      background-color: white;
    }

    #flexible-expenses .allocation-line:nth-child(odd) {
      background-color: var(--secondary-color);
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Department Budget Allocation</h1>

    <div class="header-controls">
      <div class="filters">
        <label for="department-filter">Home Department:</label>
        <select id="department-filter">
        </select>

        <label for="iteration-filter">Budget Iteration:</label>
        <select id="iteration-filter">
          <option value="FY25" selected>FY25 (Board Approved)</option>
          <option value="FY25-Q1">FY25-Q1 (Q1 Update)</option>
          <option value="FY25-Q2">FY25-Q2 (Q2 Update)</option>
        </select>
      </div>


    </div>

    <div class="tab-container">
      <div class="tabs">
        <button class="tab active" data-tab="staff">Staff Expenses</button>
        <button class="tab" data-tab="flexible">Flexible Expenses</button>
        <div id="currency-display"></div>
      </div>

    </div>
    <div id="staff-container" class="tab-content active">

      <!-- Existing employee containers move here -->
      <div id="employee-containers">
        <!-- Employees will be loaded here dynamically -->
        <div class="loading">Loading employee data...</div>
      </div>
      <div class="newemployee-bottom">
        <button id="add-employee-btn2" type="button">+ Add New Employee</button>
      </div>
      <div class="grand-total">

        <div class="grand-total-row">
          <span>Total Salaries:</span>
          <span id="total-salaries">$0.00</span>
        </div>
        <div class="grand-total-row">
          <span>Total Salaries + Fringe:</span>
          <span id="total-salaries-with-fringe">$0.00</span>
        </div>
        <div class="grand-total-row">
          <span>Total Salaries + Fringe Allocated to Home Department:</span>
          <span id="total-allocated">$0.00</span>
        </div>
        <div class="grand-total-row">
          <span>Total Salaries + Fringe Allocated to Home Department / Core Fund:</span>
          <span id="total-allocated-core">$0.00</span>
        </div>
      </div>





    </div>
    <div id="flexible-container" class="tab-content">
      <!-- New flexible expenses content will go here -->
      <div id="flexible-expenses"></div>
      <div class="grand-total">
        <div class="grand-total-row">
          <span>Total Expenses:</span>
          <span id="total-flexible-expenses">0.00</span>
        </div>
        <div class="grand-total-row">
          <span>Total Salaries + Fringe Allocated to Home Department:</span>
          <span id="total-allocated2">$0.00</span>
        </div>
        <div class="grand-final-total-row">
          <span>Grand Total:</span>
          <span id="grand-total">$0.00</span>
        </div>
      </div>
    </div>

    <div class="save-section">
      <div>
        <div class="save-info">All changes will be saved to the current iteration: <span
            id="current-iteration-display">FY25</span></div>
        <div id="validation-summary" class="validation-summary"></div>
      </div>
      <button id="save-btn" type="button" class="save">Save Budget Data</button>
    </div>
  </div>
</body>


<script>
  // Replace the script section in index2.html with this updated version
  document.addEventListener('DOMContentLoaded', function () {
    // Global variables
    let budgetData = null;
    let employeeData = [];
    let flexibleExpensesData = [];
    let departments = [];
    let fx_rates = [];
    let expense_accounts = [];
    let currentDepartment = '';
    let currentIteration = 'FY25';
    let currentCurrency = '';
    let hasValidationErrors = false;
    let availableIterations = [];
    let expandedEmployees = new Set();

    const currencies = [
      { value: 'USD', label: 'USD' },
      { value: 'EUR', label: 'EUR' },
      { value: 'GBP', label: 'GBP' }
    ];

    // Initialize the application
    init();

    async function init() {
      try {
        await fetchBudgetData();
        setupEventListeners();
        setupMonthlyValueListeners(); // Move this here
        loadIterationData(currentIteration);
        updateIterationUI();
        renderEmployees();
        renderExpenses();
        updateTotals();
        validateAllEmployees();
        document.querySelector('.tab-container').classList.add('staff-active');
      } catch (error) {
        console.error('Failed to initialize application:', error);
        document.getElementById('employee-containers').innerHTML =
          `<div class="error-text">Failed to load employee data. Please try again.</div>`;
        document.getElementById('flexible-container').innerHTML =
          `<div class="error-text">Failed to load account data. Please try again.</div>`;
      }
    }


    function setupMonthlyValueListeners() {
      // Listen for expenses
      const expenseContainer = document.getElementById('flexible-expenses');
      expenseContainer.addEventListener('blur', handleContainerBlur, true);

      // Listen for employee values
      const employeeContainer = document.getElementById('employee-containers');
      employeeContainer.addEventListener('blur', handleContainerBlur, true);
    }

    function handleContainerBlur(e) {
      if (!e.target.classList.contains('monthly-input')) return;

      const input = e.target;
      const line = input.closest('.allocation-line');
      const monthIndex = parseInt(input.dataset.monthIndex);

      if (e.currentTarget.id === 'flexible-expenses') {
        // Handle flexible expense monthly values
        const accountIndex = parseInt(line.dataset.accountIndex);
        handleMonthlyValue(input, input.dataset.originalValue || 0, currentCurrency, (newValue) => {
          const account = expense_accounts[accountIndex];
          let expenseData = flexibleExpensesData.find(exp =>
            exp.account === account.id &&
            exp.department === currentDepartment
          );

          if (!expenseData) {
            expenseData = {
              account: account.id,
              department: currentDepartment,
              monthlyValues: Array(12).fill(0)
            };
            flexibleExpensesData.push(expenseData);
          }

          // Update the value in the monthlyValues array
          expenseData.monthlyValues[monthIndex] = newValue;
          input.dataset.originalValue = newValue;

          // Recalculate spend-to-date total
          let spendToDateTotal = 0;
          let lastActualMonth = -1;

          // Find last month with actuals across all accounts
          flexibleExpensesData.forEach(exp => {
            if (exp.actualMonthlyValues) {
              exp.actualMonthlyValues.forEach((value, idx) => {
                if (value !== null && value !== undefined) {
                  lastActualMonth = Math.max(lastActualMonth, idx);
                }
              });
            }
          });

          // Calculate spend to date (sum of all values up to lastActualMonth)
          if (lastActualMonth >= 0) {
            for (let i = 0; i <= lastActualMonth; i++) {
              spendToDateTotal += expenseData.monthlyValues[i] || 0;
            }

            // Update spend to date cell
            const spendToDateCell = line.querySelector('.spend-to-date');
            if (spendToDateCell) {
              spendToDateCell.textContent = formatCurrency(spendToDateTotal, currentCurrency);
            }
          }

          // Update line total
          const totalCell = line.querySelector('.total-value:last-child');
          const grandTotal = expenseData.monthlyValues.reduce((sum, val) => sum + (val || 0), 0);
          if (totalCell) {
            totalCell.textContent = formatCurrency(grandTotal, currentCurrency);
          }

          updateTotals();
        });
      } else if (e.currentTarget.id === 'employee-containers') {
        // Handle employee allocation monthly values
        const allocationId = parseInt(line.dataset.allocationId);
        const employeeId = parseInt(line.closest('.employee-box').dataset.employeeId);
        const employee = findEmployee(employeeId);
        if (!employee) return;

        const allocation = employee.allocations.find(a => a.id === allocationId);
        if (!allocation) return;

        handleMonthlyValue(input, input.dataset.originalValue || 0, currentCurrency, (newValue) => {
          allocation.monthlyValues[monthIndex] = newValue;
          input.dataset.originalValue = newValue;

          // Update line total
          const totalCell = line.querySelector('.total-value:last-child');
          const totalValue = allocation.monthlyValues.reduce((sum, val) => sum + (val || 0), 0);
          if (totalCell) {
            totalCell.textContent = formatCurrency(totalValue, currentCurrency);
          }

          updateTotals();
        });
      }
    }

    async function fetchBudgetData() {
      try {
        // In a real application, this would be a fetch call to an API endpoint
        // For this example, we'll simulate fetching the data
        const response = await fetch('budget-data.json');
        if (!response.ok) {
          throw new Error('Failed to fetch budget data');
        }
        budgetData = await response.json();

        // Extract available iterations from metadata
        availableIterations = budgetData.metadata.availableIterations;

        // Extract available fx rates from metadata
        fx_rates = budgetData.metadata.fx_rates;        // Extract departments from budgetData

        departments = budgetData.departments.sort((a, b) => a.value.localeCompare(b.value));

        expense_accounts = budgetData.metadata.expense_accounts;

        // Set the currentDepartment to the first department value
        if (departments.length > 0) {
          currentDepartment = departments[0].value;
          const selectedDepartment = departments.find(dept => dept.value === currentDepartment);
          currentCurrency = selectedDepartment ? selectedDepartment.currency : '';
        }

        // Populate iteration dropdown
        const iterationDropdown = document.getElementById('iteration-filter');
        iterationDropdown.innerHTML = '';
        availableIterations.forEach(iteration => {
          const option = document.createElement('option');
          option.value = iteration.id;
          option.textContent = iteration.name;
          if (iteration.id === currentIteration) {
            option.selected = true;
          }
          iterationDropdown.appendChild(option);
        });

        // Populate department dropdown
        const departmentDropdown = document.getElementById('department-filter');
        departmentDropdown.innerHTML = '';
        departments.forEach(dept => {
          const option = document.createElement('option');
          option.value = dept.value;
          option.textContent = dept.label;
          if (dept.value === currentDepartment) {
            option.selected = true;
          }
          departmentDropdown.appendChild(option);
        });

        displayCurrency();

      } catch (error) {
        console.error('Failed to fetch budget data:', error);
        throw error;
      }
    }

    function loadIterationData(iterationId) {
      const iteration = budgetData.iterations.find(iter => iter.iterationId === iterationId);
      if (!iteration) {
        console.error(`Iteration with ID ${iterationId} not found`);
        return;
      }

      employeeData = iteration.employees.map(employee => {
        // Initialize fields that we aren't getting from the DB/JSON
        employee.salaryOld = employee.salary;
        employee.salaryChangeMonth = 0;
        employee.currency = employee.currency || currentCurrency;
        employee.isExisting = true;
        employee.domicile = employee.domicile || ''; // Ensure domicile field exists

        // If the employee has no allocations, create a default one
        if (!employee.allocations || employee.allocations.length === 0) {
          employee.allocations = [{
            id: Date.now() + 1, // Another temporary ID
            department: currentDepartment,
            percent: 100,
            percentCore: 100,
            monthlyValues: generateMonthlyValues(employee.salary, employee.salaryOld, employee.salaryChangeMonth, 100, employee.currency)
          }];
        }

        // Ensure that each iteration has a flexibleExpenses array
        budgetData.iterations.forEach(iteration => {
          if (!iteration.flexibleExpenses) {
            iteration.flexibleExpenses = [];
          }
        });

        return employee;
      });

      flexibleExpensesData = iteration.flexibleExpenses.map(expense => ({
        account: expense.account,
        department: expense.department,
        monthlyValues: [...expense.monthlyValues],
        actualMonthlyValues: expense.actualMonthlyValues ? [...expense.actualMonthlyValues] : [],
        totalAllocation: expense.totalAllocation,
        allocationType: expense.allocationType,
        CustomName: expense.CustomName,
        investmentRequest: expense.investmentRequest,
        justification: expense.justification
      }));
      currentIteration = iterationId;
    }

    function updateIterationUI() {
      document.getElementById('current-iteration-display').textContent =
        availableIterations.find(iter => iter.id === currentIteration)?.name || currentIteration;
    }

    function setupEventListeners() {
      // Department filter change event
      document.getElementById('department-filter').addEventListener('change', function (e) {
        currentDepartment = e.target.value;
        const selectedDepartment = departments.find(dept => dept.value === currentDepartment);
        currentCurrency = selectedDepartment ? selectedDepartment.currency : '';
        renderEmployees();
        renderExpenses();
        updateTotals();
        validateAllEmployees();
        displayCurrency();
      });

      // Iteration filter change event
      document.getElementById('iteration-filter').addEventListener('change', function (e) {
        currentIteration = e.target.value;
        loadIterationData(currentIteration);
        updateIterationUI();
        renderEmployees();
        renderExpenses();
        updateTotals();
        validateAllEmployees();
      });

      // Add event listener for both add-employee-btn (top of page) and add-employee-btn2 (bottom of page)
      document.querySelectorAll('#add-employee-btn, #add-employee-btn2').forEach(button => {
        button.addEventListener('click', () => {
          addNewEmployee();
          window.scrollTo({
            top: document.body.scrollHeight, // Scroll to the bottom
            behavior: "smooth"               // Smooth scroll
          });
        });
      });


      // Save button
      document.getElementById('save-btn').addEventListener('click', saveData);

      // Add tab switching functionality
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          // Remove active class from all tabs and content
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

          // Add active class to clicked tab and corresponding content
          tab.classList.add('active');
          const tabContent = document.getElementById(`${tab.dataset.tab}-container`);
          tabContent.classList.add('active');

          // Update tab container class based on active tab
          const tabContainer = document.querySelector('.tab-container');
          if (tab.dataset.tab === 'staff') {
            tabContainer.classList.add('staff-active');
          } else {
            tabContainer.classList.remove('staff-active');
          }
        });
      });
    }


    function renderEmployees() {
      const container = document.getElementById('employee-containers');
      container.innerHTML = '';
      // Filter employees by home department
      const filteredEmployees = employeeData.filter(employee =>
        employee.homeDepartment === currentDepartment
      );

      if (filteredEmployees.length === 0) {
        container.innerHTML = '<div class="loading">No employees found for the selected department.</div>';
        return;
      }



      // Create the headers separately and append them one by one
      const EmpHeaderColumnTitles = [
        'Allocs', ' Employee Name', 'Job Title', 'Location', 'Current Annual Salary', 'New Annual Salary', 'Salary Change Month', 'Salary Currency'
      ];


      const Empheaders = document.createElement('div');
      Empheaders.className = 'employee-column-headers';

      EmpHeaderColumnTitles.forEach(title => {
        const div = document.createElement('div');
        div.textContent = title;
        Empheaders.appendChild(div);
      });

      container.appendChild(Empheaders);

      filteredEmployees.forEach(employee => {
        container.appendChild(createEmployeeBox(employee));
      });
    }


    function renderExpenses() {
      const ExpContainer = document.getElementById('flexible-expenses');
      ExpContainer.innerHTML = '';

      // Create a wrapper for the entire content
      const wrapper = document.createElement('div');
      wrapper.className = 'expenses-wrapper';

      // Determine last month with actuals first
      let lastActualMonth = -1;
      flexibleExpensesData.forEach(exp => {
        if (exp.actualMonthlyValues) {
          exp.actualMonthlyValues.forEach((value, monthIndex) => {
            if (value !== null && value !== undefined) {
              lastActualMonth = Math.max(lastActualMonth, monthIndex);
            }
          });
        }
      });

      // Create headers array
      const baseHeaders = [
        '', //Delete button
        'Account Name',
        'Invest Req?',
        'Total Alloc',
        'Justification',
        'Alloc Type'
      ];

      const monthHeaders = [
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
        'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'
      ];

      // Build complete headers array with Spend to Date in correct position
      let columnTitles = [...baseHeaders];
      for (let i = 0; i < monthHeaders.length; i++) {
        columnTitles.push(monthHeaders[i]);
        if (i === lastActualMonth && lastActualMonth >= 0) {
          columnTitles.push('Spend to Date');
        }
      }
      columnTitles.push('Total');

      // Create header elements
      const headers = document.createElement('div');
      headers.className = 'column-headers';
      columnTitles.forEach(title => {
        const div = document.createElement('div');
        div.textContent = title;
        headers.appendChild(div);
      });

      wrapper.appendChild(headers);

      // Add account lines
      expense_accounts.forEach((account, index) => {

        let expenseData = flexibleExpensesData.find(exp =>
          exp.account === account.id && exp.department === currentDepartment
        );

        if (!expenseData) {
          expenseData = {
            account: account.id,
            department: currentDepartment,
            monthlyValues: Array(12).fill(0)
          };
          flexibleExpensesData.push(expenseData);
        }

        const accountLine = createAccountLine(account, expenseData, index);
        wrapper.appendChild(accountLine);
      });

      ExpContainer.appendChild(wrapper);


      // Add bottom section for new expense button
      const bottomSection = document.createElement('div');
      bottomSection.className = 'newexpense-bottom';

      const addAccountBtn2 = document.createElement('button');
      addAccountBtn2.textContent = '+ Add Investments or Other Expenses';
      addAccountBtn2.type = 'button';
      addAccountBtn2.addEventListener('click', addNewAccount);

      bottomSection.appendChild(addAccountBtn2);
      ExpContainer.appendChild(bottomSection);
    }



    function addNewAccount() {
      const newAccount = {
        id: "custom",
        Name: "",
        CustomName: "Enter Investment/Expense Description", // This will be updated when user types
        Type: "Expense",
        Category: "Operating Expenses",
        Subcategory: "Other",
        justification: ""
      };

      expense_accounts.push(newAccount);

      // Create corresponding expense data with CustomName
      const newExpenseData = {
        account: newAccount.id,
        department: currentDepartment,
        monthlyValues: Array(12).fill(0),
        CustomName: newAccount.CustomName,  // Add CustomName to expense data
        investmentRequest: false  // Add investment request field
      };
      flexibleExpensesData.push(newExpenseData);

      renderExpenses();
    }

    function getLastActualMonth() {
      let lastActualMonth = -1;
      flexibleExpensesData.forEach(exp => {
        if (exp.actualMonthlyValues) {
          exp.actualMonthlyValues.forEach((value, idx) => {
            if (value !== null && value !== undefined) {
              lastActualMonth = Math.max(lastActualMonth, idx);
            }
          });
        }
      });
      return lastActualMonth;
    }

    function findExpenseData(accountId, department) {
      return flexibleExpensesData.find(exp =>
        exp.account === accountId &&
        exp.department === department
      );
    }

    function createAccountLine(account, expenseData, index) {
      const line = document.createElement('div');
      line.className = 'allocation-line';
      line.dataset.accountIndex = index;

      // Add delete button for custom accounts
      if (account.id === "custom") {
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-line';
        deleteBtn.innerHTML = '&times;';
        deleteBtn.addEventListener('click', () => {
          if (confirm('Are you sure you want to delete this expense line?')) {
            // Remove from expense_accounts array
            const accountIndex = expense_accounts.findIndex(acc =>
              acc.id === account.id && acc.CustomName === account.CustomName
            );
            if (accountIndex !== -1) {
              expense_accounts.splice(accountIndex, 1);
            }

            // Remove from flexibleExpensesData array
            const expenseIndex = flexibleExpensesData.findIndex(exp =>
              exp.account === account.id && exp.CustomName === expenseData.CustomName
            );
            if (expenseIndex !== -1) {
              flexibleExpensesData.splice(expenseIndex, 1);
            }

            // Re-render the expenses grid
            renderExpenses();
          }
        });
        line.appendChild(deleteBtn);
      } else {
        // Add empty div for alignment
        const emptyDiv = document.createElement('div');
        line.appendChild(emptyDiv);
      }

      // Find last month with actuals first
      const monthsWithActuals = new Set();
      let lastActualMonth = -1;
      flexibleExpensesData.forEach(exp => {
        if (exp.actualMonthlyValues) {
          exp.actualMonthlyValues.forEach((value, monthIndex) => {
            if (value !== null && value !== undefined) {
              monthsWithActuals.add(monthIndex);
              lastActualMonth = Math.max(lastActualMonth, monthIndex);
            }
          });
        }
      });

      // Account Name handling
      if (account.id === "custom") {
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'account-name-input';
        nameInput.value = expenseData.CustomName || account.CustomName || '';
        nameInput.placeholder = 'Enter Investment/Expense Description';
        nameInput.addEventListener('blur', e => {
          const newName = e.target.value;
          account.CustomName = newName;
          account.Name = newName;
          expenseData.CustomName = newName; // Save to expense data

          // Update the corresponding flexible expense data
          const expenseIndex = flexibleExpensesData.findIndex(exp =>
            exp.account === account.id &&
            exp.department === currentDepartment
          );
          if (expenseIndex !== -1) {
            flexibleExpensesData[expenseIndex].CustomName = newName;
          }
        });
        line.appendChild(nameInput);
      } else {
        const nameDiv = document.createElement('div');
        nameDiv.textContent = account.Name;
        line.appendChild(nameDiv);
      }

      if (account.id === "custom") {
        const investmentCell = document.createElement('div');
        const investmentCheckbox = document.createElement('input');
        investmentCheckbox.type = 'checkbox';
        investmentCheckbox.checked = expenseData.investmentRequest || false;
        investmentCheckbox.addEventListener('change', e => {
          // Update the expenseData directly
          expenseData.investmentRequest = e.target.checked;

          // Find and update in flexibleExpensesData array
          const expenseIndex = flexibleExpensesData.findIndex(exp =>
            exp.account === account.id &&
            exp.department === currentDepartment
          );
          if (expenseIndex !== -1) {
            flexibleExpensesData[expenseIndex].investmentRequest = e.target.checked;
          }
        });
        investmentCell.appendChild(investmentCheckbox);
        line.appendChild(investmentCell);
      } else {
        // Add empty cell for non-custom expenses
        const emptyCell = document.createElement('div');
        line.appendChild(emptyCell);
      }

      // Total Allocation Input
      const totalAllocInput = document.createElement('input');
      totalAllocInput.type = 'text';
      totalAllocInput.className = 'total-alloc-input';
      totalAllocInput.value = formatCurrency(expenseData.totalAllocation || 0, currentCurrency);
      totalAllocInput.addEventListener('blur', e => {
        handleMonthlyValue(e.target, expenseData.totalAllocation || 0, currentCurrency, (newValue) => {
          expenseData.totalAllocation = newValue;
          distributeAllocation(expenseData, line);
        });
      });
      line.appendChild(totalAllocInput);

      // Justification
      const ExpJustificationInput = document.createElement('input');
      ExpJustificationInput.type = 'text';
      ExpJustificationInput.className = 'total-just-input';
      ExpJustificationInput.value = expenseData.justification || '';

      line.appendChild(ExpJustificationInput);

      // Create allocation type dropdown using the same lastActualMonth
      // In createAccountLine function, update the allocation types check:
      const availableAllocTypes = [
        { value: 'straight-line', label: 'Straight Line' }
      ];

      // Check if quarters are still available
      const q1Available = getAvailableMonths(0, 2).length > 0;
      const q2Available = getAvailableMonths(3, 5).length > 0;
      const q3Available = getAvailableMonths(6, 8).length > 0;
      const q4Available = getAvailableMonths(9, 11).length > 0;

      if (q1Available) availableAllocTypes.push({ value: 'q1', label: 'Q1 Only (Jul-Sep)' });
      if (q2Available) availableAllocTypes.push({ value: 'q2', label: 'Q2 Only (Oct-Dec)' });
      if (q3Available) availableAllocTypes.push({ value: 'q3', label: 'Q3 Only (Jan-Mar)' });
      if (q4Available) availableAllocTypes.push({ value: 'q4', label: 'Q4 Only (Apr-Jun)' });

      // Check if halves are still available
      const firstHalfAvailable = getAvailableMonths(0, 5).length > 0;
      const secondHalfAvailable = getAvailableMonths(6, 11).length > 0;

      if (firstHalfAvailable) availableAllocTypes.push({ value: 'first-half', label: '1H FY (Jul-Dec)' });
      if (secondHalfAvailable) availableAllocTypes.push({ value: 'second-half', label: '2H FY (Jan-Jun)' });
      // Create allocation type dropdown with only available options
      const allocTypeSelect = document.createElement('select');
      allocTypeSelect.className = 'alloc-type-select';
      availableAllocTypes.forEach(type => {
        const option = document.createElement('option');
        option.value = type.value;
        option.textContent = type.label;
        if (type.value === (expenseData.allocationType || 'straight-line')) {
          option.selected = true;
        }
        allocTypeSelect.appendChild(option);
      });

      allocTypeSelect.addEventListener('change', e => {
        expenseData.allocationType = e.target.value;
        distributeAllocation(expenseData, line);
      });
      line.appendChild(allocTypeSelect);

      //We don't want to distribute on load because we'd be overwriting user-entered values. 
      //distributeAllocation(expenseData, line);

      // Monthly values container
      const monthlyContainer = document.createElement('div');
      monthlyContainer.className = 'monthly-values';

      // Monthly inputs
      let spendToDateTotal = 0;  // Only for actual values
      let grandTotal = 0;        // For all values

      for (let i = 0; i < 12; i++) {
        const monthInput = document.createElement('input');
        monthInput.type = 'text';
        monthInput.className = 'monthly-input';

        const hasAccountActual = expenseData.actualMonthlyValues &&
          i < expenseData.actualMonthlyValues.length &&
          expenseData.actualMonthlyValues[i] !== null;

        const isMonthLocked = monthsWithActuals.has(i);

        if (hasAccountActual || isMonthLocked) {
          // Use actual value if available, otherwise use planned value for locked months
          const value = hasAccountActual ? expenseData.actualMonthlyValues[i] :
            expenseData.monthlyValues[i] || 0;
          monthInput.value = formatCurrency(value, currentCurrency);
          monthInput.disabled = true;
          monthInput.classList.add(hasAccountActual ? 'actual-value' : 'locked-month');
          expenseData.monthlyValues[i] = value;
          spendToDateTotal += value;  // Add to spend-to-date total
          grandTotal += value;        // Also add to grand total
        } else {
          const plannedValue = expenseData.monthlyValues[i] || 0;
          monthInput.value = formatCurrency(plannedValue, currentCurrency);
          monthInput.dataset.monthIndex = i;
          monthInput.dataset.originalValue = plannedValue;
          grandTotal += plannedValue;  // Only add to grand total
        }

        line.appendChild(monthInput);

        // Add Spend to Date column after last actual month
        if (i === lastActualMonth && lastActualMonth >= 0) {
          const spendToDateCell = document.createElement('div');
          spendToDateCell.className = 'monthly-input total-value spend-to-date';
          spendToDateCell.textContent = formatCurrency(spendToDateTotal, currentCurrency);
          line.appendChild(spendToDateCell);
        }
      }

      // Total cell (all values)
      const totalCell = document.createElement('div');
      totalCell.className = 'monthly-input total-value';
      totalCell.textContent = formatCurrency(grandTotal, currentCurrency);
      line.appendChild(totalCell);

      return line;
    }


    function getAvailableMonths(start, end) {
      const lastActualMonth = getLastActualMonth();
      let months = [];
      for (let i = Math.max(start, lastActualMonth + 1); i <= end; i++) {
        months.push(i);
      }
      return months;
    }

    function distributeAllocation(expenseData, line) {
      const total = expenseData.totalAllocation || 0;
      const type = expenseData.allocationType || 'straight-line';

      // Use the helper to get lastActualMonth
      let lastActualMonth = getLastActualMonth();

      // Calculate spend to date
      let spendToDate = 0;
      for (let i = 0; i <= lastActualMonth; i++) {
        if (expenseData.actualMonthlyValues && expenseData.actualMonthlyValues[i] !== null) {
          spendToDate += expenseData.actualMonthlyValues[i];
        } else if (expenseData.monthlyValues[i]) {
          spendToDate += expenseData.monthlyValues[i];
        }
      }

      const remainingTotal = total - spendToDate;
      const startMonth = lastActualMonth + 1;
      const newMonthlyValues = [...expenseData.monthlyValues];

      // Clear future values first
      for (let i = startMonth; i < 12; i++) {
        newMonthlyValues[i] = 0;
      }

      function distributeAmount(amount, months) {
        if (months.length === 0) return;
        const amountToDistribute = Math.max(0, amount);
        const monthlyAmount = Math.floor(amountToDistribute / months.length);
        let distributed = 0;
        for (let i = 0; i < months.length - 1; i++) {
          const monthIndex = months[i];
          newMonthlyValues[monthIndex] = monthlyAmount;
          distributed += monthlyAmount;
        }
        const lastMonthIndex = months[months.length - 1];
        const remainder = amountToDistribute - distributed;
        newMonthlyValues[lastMonthIndex] = remainder;
      }

      // Update allocation based on type
      switch (type) {
        case 'straight-line':
          distributeAmount(remainingTotal, getAvailableMonths(startMonth, 11));
          break;
        case 'q1':
          distributeAmount(remainingTotal, getAvailableMonths(0, 2));
          break;
        case 'q2':
          distributeAmount(remainingTotal, getAvailableMonths(3, 5));
          break;
        case 'q3':
          distributeAmount(remainingTotal, getAvailableMonths(6, 8));
          break;
        case 'q4':
          distributeAmount(remainingTotal, getAvailableMonths(9, 11));
          break;
        case 'first-half':
          distributeAmount(remainingTotal, getAvailableMonths(0, 5));
          break;
        case 'second-half':
          distributeAmount(remainingTotal, getAvailableMonths(6, 11));
          break;
      }

      expenseData.monthlyValues = newMonthlyValues;

      const inputs = line.querySelectorAll('input.monthly-input');
      newMonthlyValues.forEach((value, index) => {
        if (inputs[index]) {
          inputs[index].value = formatCurrency(value, currentCurrency);
        }
      });

      const totalCell = line.querySelector('.total-value:last-child');
      const spendToDateCell = line.querySelector('.spend-to-date');

      if (spendToDateCell) {
        spendToDateCell.textContent = formatCurrency(spendToDate, currentCurrency);
      }

      updateLineTotal(expenseData, totalCell);
      updateTotals();
    }

    function getAvailableMonths(start, end) {
      // Find last month with actuals across all accounts
      let lastActualMonth = -1;
      flexibleExpensesData.forEach(exp => {
        if (exp.actualMonthlyValues) {
          exp.actualMonthlyValues.forEach((value, idx) => {
            if (value !== null && value !== undefined) {
              lastActualMonth = Math.max(lastActualMonth, idx);
            }
          });
        }
      });

      // Return all months in the range that are after lastActualMonth
      let months = [];
      // Ensure we include end in the range
      for (let i = Math.max(start, lastActualMonth + 1); i <= end; i++) {
        months.push(i);
      }
      return months;
    }

    function handleMonthlyValue(input, currentValue, currency, onSuccess) {
      let rawValue = input.value.replace(/[^0-9.-]+/g, '');

      if (!/^\d+$/.test(rawValue)) {
        alert("Please enter a valid whole number.");
        input.value = formatCurrency(currentValue, currency);
        return false;
      }

      const newValue = parseInt(rawValue);
      input.value = formatCurrency(newValue, currency);

      if (onSuccess) {
        onSuccess(newValue);
      }

      return newValue;
    }
    function updateLineTotal(expenseData, totalCell) {
      if (totalCell) {
        const total = expenseData.monthlyValues.reduce((sum, val) => sum + val, 0);
        totalCell.textContent = formatCurrency(total, currentCurrency);
      } else {
        console.warn('totalCell is null in updateLineTotal');
      }
    }



    function toggleEmployeeExpansion(employeeId) {
      if (expandedEmployees.has(employeeId)) {
        expandedEmployees.delete(employeeId);
      } else {
        expandedEmployees.add(employeeId);
      }
    }

    function createEmployeeBox(employee) {

      const box = document.createElement('div');
      box.className = 'employee-box';
      box.dataset.employeeId = employee.id;
      if (expandedEmployees.has(employee.id)) {
        box.classList.add('expanded');
      }
      if (expandedEmployees.has(employee.id)) {
        box.classList.remove('expanded');
      }



      // Employee info section
      const info = document.createElement('div');
      info.className = 'employee-info';


      // Expand/Collapse button
      //   const expandBtn = document.createElement('button');
      //expandBtn.className = 'expand-button';
      //expandBtn.textContent = expandedEmployees.has(employee.id) ? '▼' : '▶';
      //expandBtn.addEventListener('click', () => {
      //    const allocations = box.querySelector('.employee-allocations');
      //    const isExpanded = allocations.classList.toggle('expanded');
      //    expandBtn.textContent = isExpanded ? '▼' : '▶';
      //    toggleEmployeeExpansion(employee.id);
      // });
      // info.appendChild(expandBtn);

      // Allocations count
      const AllocsGroup = document.createElement('div');
      AllocsGroup.className = 'field-group';
      const allocsInput = document.createElement('label');
      allocsInput.textContent = `${employee.allocations.length} ▶`;
      AllocsGroup.addEventListener('click', () => {
        const allocations = box.querySelector('.employee-allocations');
        const isExpanded = allocations.classList.toggle('expanded');
        allocsInput.textContent = `${employee.allocations.length} ${isExpanded ? '▼' : '▶'}`;
        toggleEmployeeExpansion(employee.id);
      });
      AllocsGroup.appendChild(allocsInput);
      info.appendChild(AllocsGroup);


      // Name field
      const nameGroup = document.createElement('div');
      nameGroup.className = 'field-group';
      const nameLabel = document.createElement('label');
      nameLabel.textContent = 'Employee Name';
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = employee.name;
      nameInput.disabled = employee.isExisting;
      nameInput.addEventListener('change', e => updateEmployeeField(employee.id, 'name', e.target.value));
      // nameGroup.appendChild(nameLabel);
      nameGroup.appendChild(nameInput);
      info.appendChild(nameGroup);

      // Job Title field
      const titleGroup = document.createElement('div');
      titleGroup.className = 'field-group';
      const titleLabel = document.createElement('label');
      titleLabel.textContent = 'Job Title';
      const titleInput = document.createElement('input');
      titleInput.type = 'text';
      titleInput.value = employee.jobTitle;
      titleInput.addEventListener('change', e => updateEmployeeField(employee.id, 'jobTitle', e.target.value));
      // titleGroup.appendChild(titleLabel);
      titleGroup.appendChild(titleInput);
      info.appendChild(titleGroup);

      // Add Domicile dropdown
      const domicileGroup = document.createElement('div');
      domicileGroup.className = 'field-group';
      const domicileLabel = document.createElement('label');
      domicileLabel.textContent = 'Location';
      const domicileSelect = document.createElement('select');

      // Add empty option first
      const emptyOption = document.createElement('option');
      emptyOption.value = '';
      emptyOption.textContent = 'Select Location';
      domicileSelect.appendChild(emptyOption);

      // Add options from fringe_rates
      budgetData.metadata.fringe_rates.forEach(rate => {
        const option = document.createElement('option');
        option.value = rate.domicile;
        option.textContent = rate.domicile;
        if (rate.domicile === employee.domicile) {
          option.selected = true;
        }
        domicileSelect.appendChild(option);
      });

      domicileSelect.addEventListener('change', e => {
        updateEmployeeField(employee.id, 'domicile', e.target.value);
        updateTotals();
        validateEmployee(employee);
      });

      //  domicileGroup.appendChild(domicileLabel);
      domicileGroup.appendChild(domicileSelect);
      info.appendChild(domicileGroup);

      // SalaryOld field
      const oldsalaryGroup = document.createElement('div');
      oldsalaryGroup.className = 'field-group';
      const oldsalaryLabel = document.createElement('label');
      oldsalaryLabel.textContent = 'Current Annual Salary';
      const oldsalaryDisplay = document.createElement('div'); // Changed to div
      if (employee.isExisting == true) { oldsalaryDisplay.textContent = formatCurrency(employee.salaryOld, employee.currency); }
      else { oldsalaryDisplay.textContent = 'N/A' };

      //  oldsalaryGroup.appendChild(oldsalaryLabel);
      oldsalaryGroup.appendChild(oldsalaryDisplay); // Append the div
      info.appendChild(oldsalaryGroup);

      // Salary field
      const salaryGroup = document.createElement('div');
      salaryGroup.className = 'field-group';
      const salaryLabel = document.createElement('label');
      salaryLabel.textContent = 'New Annual Salary';
      const salaryInput = document.createElement('input');
      salaryInput.type = 'text';
      salaryInput.value = formatCurrency(employee.salary, employee.currency);
      salaryInput.addEventListener('change', e => {
        // Get the raw input value, remove non-numeric characters (except dots)
        let rawValue = e.target.value.replace(/[^0-9.]/g, '');

        // Validate if the value is a whole number
        if (!/^\d+$/.test(rawValue)) {  // Check if the value is a whole number
          alert("Please enter a valid whole number.");
          e.target.value = previousValue; // Reset to the previous valid value
        } else {
          // If valid, format and update the input
          e.target.value = formatCurrency(parseInt(rawValue), employee.currency);

          // Remove commas and $ sign before passing to updateSalary
          let cleanValue = e.target.value.replace(/[^0-9.]/g, ''); // Remove any commas and $ sign
          updateSalary(employee.id, parseFloat(cleanValue), employee.salaryOld, employee.salaryChangeMonth, employee.currency);

          // Update the previous value to the current valid value
          previousValue = e.target.value; // Save the newly formatted value
        }
      });

      // salaryGroup.appendChild(salaryLabel);
      salaryGroup.appendChild(salaryInput);
      info.appendChild(salaryGroup);

      // Month of Salary Change
      const salarychangeGroup = document.createElement('div');
      salarychangeGroup.className = 'field-group';
      const salarychangeLabel = document.createElement('label');
      if (employee.isExisting == true) { salarychangeLabel.textContent = 'Month of Salary Change'; }
      else { salarychangeLabel.textContent = 'Month of Hire'; }
      const salarychangeInput = document.createElement('select');
      salarychangeInput.className = 'salary-change-month';
      salarychangeInput.addEventListener('change', e => {
        updateSalary(employee.id, employee.salary, employee.salaryOld, e.target.value, employee.currency);
      });

      const months = [
        { value: 0, label: 'July' },
        { value: 1, label: 'August' },
        { value: 2, label: 'September' },
        { value: 3, label: 'October' },
        { value: 4, label: 'November' },
        { value: 5, label: 'December' },
        { value: 6, label: 'January' },
        { value: 7, label: 'February' },
        { value: 8, label: 'March' },
        { value: 9, label: 'April' },
        { value: 10, label: 'May' },
        { value: 11, label: 'June' }
      ];

      months.forEach(month => {
        const option = document.createElement('option');
        option.value = month.value;
        option.textContent = month.label;
        salarychangeInput.appendChild(option);
      });

      salarychangeInput.value = employee.salaryChangeMonth;

      //  salarychangeGroup.appendChild(salarychangeLabel);
      salarychangeGroup.appendChild(salarychangeInput);
      info.appendChild(salarychangeGroup);

      // Salary Currency Override
      const salaryCurrencyGroup = document.createElement('div');
      salaryCurrencyGroup.className = 'field-group';
      const salaryCurrencyLabel = document.createElement('label');
      salaryCurrencyLabel.textContent = 'Salary Currency';
      const salaryCurrencyInput = document.createElement('select');
      salaryCurrencyInput.className = 'salary-change-currency';
      salaryCurrencyInput.addEventListener('change', e => {
        updateSalary(employee.id, employee.salary, employee.salaryOld, employee.salaryChangeMonth, e.target.value);
      });



      currencies.forEach(currency => {
        const option = document.createElement('option');
        option.value = currency.value;
        option.textContent = currency.label;
        salaryCurrencyInput.appendChild(option);
      });

      salaryCurrencyInput.value = employee.currency;

      // salaryCurrencyGroup.appendChild(salaryCurrencyLabel);
      salaryCurrencyGroup.appendChild(salaryCurrencyInput);
      info.appendChild(salaryCurrencyGroup);







      // Delete button for new employees only
      if (!employee.isExisting) {
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'danger';
        deleteBtn.innerHTML = 'Delete Employee';
        deleteBtn.addEventListener('click', () => {
          //if (confirm('Are you sure you want to delete this employee?')) {
          deleteEmployee(employee.id);
          //}
        });
        info.appendChild(deleteBtn);
      }

      box.appendChild(info);

      // Column headers
      const headers = document.createElement('div');
      headers.className = 'column-headers';

      // Create the button
      const addLineBtn = document.createElement('button');
      addLineBtn.textContent = '+';
      addLineBtn.classList.add('add-line');
      // Add event listener before appending
      addLineBtn.addEventListener('click', () => {
        addAllocationLine(employee.id);
        allocsInput.textContent = `Allocations: ${employee.allocations.length}`;
      });
      // Append button first
      headers.appendChild(addLineBtn);

      // Create the headers separately and append them one by one
      const columnTitles = [
        'Allocation %', 'Department', '% Core', 'Jul', 'Aug', 'Sep', 'Oct',
        'Nov', 'Dec', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Total' // Added 'Total'
      ];



      // Allocation lines
      const allocationsSection = document.createElement('div');
      allocationsSection.className = 'employee-allocations';
      if (expandedEmployees.has(employee.id)) {
        allocationsSection.classList.add('expanded');
      }


      columnTitles.forEach(title => {
        const div = document.createElement('div');
        div.textContent = title;
        headers.appendChild(div);
      });

      allocationsSection.appendChild(headers);

      employee.allocations.forEach(allocation => {
        allocationsSection.appendChild(createAllocationLine(employee.id, allocation));
      });

      allocationsSection.appendChild(createGrandTotalRow(employee));




      // New hires justification line
      if (employee.isExisting === false || employee.justification != null) {
        const hireJustificationGroup = document.createElement('div');
        hireJustificationGroup.className = 'allocation-line grand-total-value';

        hireJustificationGroup.className = 'allocation-line justification-value';
        const hireJustificationLabel = document.createElement('label');
        hireJustificationLabel.textContent = 'Justification for hire: ';
        const hireJustificationInput = document.createElement('input');
        hireJustificationInput.type = 'text';
        hireJustificationInput.value = employee.justification;
        hireJustificationInput.addEventListener('blur', e => {
          updateEmployeeField(employee.id, 'justification', e.target.value);
          validateEmployee(employee);
        });
        hireJustificationGroup.appendChild(hireJustificationLabel);
        hireJustificationGroup.appendChild(hireJustificationInput); // Append the div
        allocationsSection.appendChild(hireJustificationGroup);
      }

      // Error message container (initially empty)
      const errorMsg = document.createElement('div');
      errorMsg.className = 'error-message';
      errorMsg.id = `error-${employee.id}`;
      allocationsSection.appendChild(errorMsg);

      box.appendChild(allocationsSection);


      return box;
    }

    function createAllocationLine(employeeId, allocation) {
      const line = document.createElement('div'); 0
      line.className = 'allocation-line';
      line.dataset.allocationId = allocation.id;

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-line';
      deleteBtn.innerHTML = '&times;';
      deleteBtn.addEventListener('click', () => deleteAllocationLine(employeeId, allocation.id));
      line.appendChild(deleteBtn);

      // Allocation percentage
      const percentInput = document.createElement('input');
      percentInput.type = 'text';
      percentInput.min = 0;
      percentInput.max = 100;
      percentInput.value = allocation.percent + '%';
      percentInput.addEventListener('change', e => {
        let value = parseFloat(e.target.value.replace(/[^0-9.]/g, ''));

        // Validate if the value is between 0 and 100
        if (value >= 0 && value <= 100) {
          // If valid, update the value and proceed with the logic
          previousValue = e.target.value; // Update the previous value with the valid one
          updateAllocationPercent(employeeId, allocation.id, parseFloat(e.target.value))
        } else {
          alert('Please enter a value between 0 and 100.');
          // Reset to the previous valid value
          e.target.value = previousValue + '%';
        }
      });
      line.appendChild(percentInput);

      // Department dropdown
      const deptSelect = document.createElement('select');
      departments.forEach(dept => {
        const option = document.createElement('option');
        option.value = dept.value;
        option.textContent = dept.label;
        if (dept.value === allocation.department) {
          option.selected = true;
        }
        deptSelect.appendChild(option);
      });
      deptSelect.addEventListener('change', e =>
        updateAllocationField(employeeId, allocation.id, 'department', e.target.value)
      );
      line.appendChild(deptSelect);

      // Core Allocation percentage
      const percentCoreInput = document.createElement('input');
      percentCoreInput.type = 'text';
      percentCoreInput.min = 0;
      percentCoreInput.max = 100;
      percentCoreInput.value = allocation.percentCore + '%';

      percentCoreInput.addEventListener('change', e => {
        let value = parseFloat(e.target.value.replace(/[^0-9.]/g, ''));

        // Validate if the value is between 0 and 100
        if (value >= 0 && value <= 100) {
          updateAllocationField(employeeId, allocation.id, 'percentCore', value);

          // Format the input
          e.target.value = value + '%';

          // Update totals to reflect the new percentCore value
          updateTotals();

          // Optional: validate the employee
          //validateEmployee(employeeId);

        } else {
          alert('Please enter a value between 0 and 100.');
          // Reset to the previous valid value
          e.target.value = allocation.percentCore + '%';
        }
      });
      line.appendChild(percentCoreInput);

      // Monthly values
      allocation.monthlyValues.forEach((value, index) => {
        const monthInput = document.createElement('input');
        monthInput.type = 'text';
        monthInput.className = 'monthly-input';
        monthInput.value = formatCurrency(value, currentCurrency);
        monthInput.dataset.monthIndex = index;
        monthInput.dataset.originalValue = value; // Store original value for validation
        line.appendChild(monthInput);
      });
      // Calculate and display the total of monthly values
      const totalValue = allocation.monthlyValues.reduce((sum, val) => sum + val, 0);
      const totalCell = document.createElement('div');
      totalCell.className = 'monthly-input total-value';
      totalCell.textContent = formatCurrency(totalValue, currentCurrency);
      totalCell.id = `linetotal-${allocation.id}`; // Unique ID using allocation.id
      line.appendChild(totalCell);

      return line;
    }

    function addNewEmployee() {
      const newEmployee = {
        id: Date.now(), // Use timestamp as temporary ID
        name: 'New Employee',
        jobTitle: 'Job Title',
        domicile: '',
        salary: 0,
        salaryOld: 0,
        salaryChangeMonth: 0,
        currency: currentCurrency,
        homeDepartment: currentDepartment,
        isExisting: false,
        justification: '',
        allocations: [
          {
            id: Date.now() + 1, // Another temporary ID
            department: currentDepartment,
            percent: 100,
            percentCore: 100,
            monthlyValues: Array(12).fill(0)
          }
        ]
      };

      employeeData.push(newEmployee);
      expandedEmployees.add(newEmployee.id);
      renderEmployees();
      updateTotals();
      validateAllEmployees();
    }

    function deleteEmployee(employeeId) {
      if (confirm('Are you sure you want to delete this employee?')) {
        employeeData = employeeData.filter(employee => employee.id !== employeeId);
        renderEmployees();
        updateTotals();
        validateAllEmployees();
      }
    }

    function addAllocationLine(employeeId) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      const newAllocation = {
        id: Date.now(), // Use timestamp as temporary ID
        department: currentDepartment,
        percent: 0,
        percentCore: 100,
        monthlyValues: generateMonthlyValues(employee.salary, employee.salaryOld, employee.salaryChangeMonth, 0, employee.currency)
      };

      employee.allocations.push(newAllocation);
      renderEmployees();
      validateAllEmployees();

      // Update allocations count
      const allocsInput = document.querySelector(`.employee-box[data-employee-id="${employeeId}"] .field-group label`);
      if (allocsInput) {
        const allocations = document.querySelector(`.employee-box[data-employee-id="${employeeId}"] .employee-allocations`);
        const isExpanded = allocations.classList.contains('expanded');
        allocsInput.textContent = `${employee.allocations.length} ${isExpanded ? '▼' : '▶'}`;
      }
    }

    function deleteAllocationLine(employeeId, allocationId) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      if (employee.allocations.length <= 1) {
        alert('Cannot delete the last allocation line. Every employee must have at least one allocation.');
        return;
      }

      employee.allocations = employee.allocations.filter(allocation => allocation.id !== allocationId);
      renderEmployees();
      validateAllEmployees();
      updateTotals();

      const allocsInput = document.querySelector(`.employee-box[data-employee-id="${employeeId}"] .field-group label`);
      if (allocsInput) {
        const allocations = document.querySelector(`.employee-box[data-employee-id="${employeeId}"] .employee-allocations`);
        const isExpanded = allocations.classList.contains('expanded');
        allocsInput.textContent = `${employee.allocations.length} ${isExpanded ? '▼' : '▶'}`;
      }
    }

    function updateEmployeeField(employeeId, field, value) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      employee[field] = value;
    }

    function updateSalary(employeeId, newSalary, salaryOld, salaryChangeMonth, currency) {
      const employee = findEmployee(employeeId);

      if (!employee) return;

      employee.currency = currency;
      employee.salary = newSalary;
      employee.salaryChangeMonth = salaryChangeMonth;
      //alert(salaryChangeMonth);

      // Update all allocation monthly values
      employee.allocations.forEach(allocation => {
        allocation.monthlyValues = generateMonthlyValues(newSalary, salaryOld, salaryChangeMonth, allocation.percent, currency);
      });

      renderEmployees();
      updateTotals();
      validateAllEmployees();
    }

    function updateAllocationField(employeeId, allocationId, field, value) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      const allocation = employee.allocations.find(a => a.id === allocationId);
      if (!allocation) return;

      allocation[field] = value;

      // If changing department, may need to update totals
      updateTotals();
      validateAllEmployees();
    }

    function updateAllocationPercent(employeeId, allocationId, newPercent) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      const allocation = employee.allocations.find(a => a.id === allocationId);
      if (!allocation) return;

      allocation.percent = newPercent;
      allocation.monthlyValues = generateMonthlyValues(employee.salary, employee.salaryOld, employee.salaryChangeMonth, newPercent, employee.currency)

      renderEmployees();
      validateAllEmployees();
      updateTotals();
    }

    function validateEmployee(employee) {
      // Check if total allocation is not 100%
      const totalPercent = employee.allocations.reduce((sum, allocation) =>
        sum + allocation.percent, 0);

      //const totalAllocatedValue = employee.allocations.reduce((sum, allocation) => {
      // Check if allocation.monthlyValues is an array and is defined
      // if (Array.isArray(allocation.monthlyValues)) {
      //   const allocationTotal = allocation.monthlyValues.reduce((subSum, value) => subSum + value, 0);
      //   return sum + allocationTotal; // Add the allocation total to the main sum
      // } else {
      //   // If monthlyValues is not an array or is undefined, skip this allocation
      //   return sum;
      // }
      //}, 0);

      const errorElement = document.getElementById(`error-${employee.id}`);
      const employeeBox = document.querySelector(`.employee-box[data-employee-id="${employee.id}"]`);
      const allocationsSection = employeeBox.querySelector('.employee-allocations');
      let errorcount = 0;
      errorElement.textContent = '';

      if (totalPercent != 100) {
        errorElement.textContent += 'Employee Allocations must total to 100%. ';
        errorcount++;
      }

      if (!employee.isExisting && !employee.justification) {
        errorElement.textContent += 'Employee Justification for hire is required. ';
        errorcount++;
      }

      if (!employee.domicile) {
        errorElement.textContent += 'Location (domicile) is required. ';
        errorcount++;
      }

      if (errorcount > 0) {
        employeeBox.classList.add('error');
        allocationsSection.classList.add('error');
        return false;
      } else {
        errorElement.textContent = '';
        employeeBox.classList.remove('error');
        allocationsSection.classList.remove('error');
        return true;
      }
    }
    //Allow for small rounding differences (e.g., $11 difference in a $100,000 salary)
    //const roundingTolerance = Math.max(12, Math.round(employee.salary * 0.0001)); // 0.01% tolerance or at least $12

    //if (totalAllocatedValue - employee.salary > roundingTolerance) {
    //  errorElement.textContent += '  The total of all Monthly values must not be greater than the salary amount.'; employeeBox.classList.add('error');
    //}


    function validateAllEmployees() {
      const filteredEmployees = employeeData.filter(employee =>
        employee.homeDepartment === currentDepartment
      );

      let validationErrors = 0;

      filteredEmployees.forEach(employee => {
        if (!validateEmployee(employee)) {
          validationErrors++;
        }
      });

      // Update save button state
      hasValidationErrors = validationErrors > 0;
      const saveBtn = document.getElementById('save-btn');
      saveBtn.disabled = hasValidationErrors;

      // Update validation summary
      const validationSummary = document.getElementById('validation-summary');
      if (hasValidationErrors) {
        validationSummary.textContent = `Please fix ${validationErrors} validation error${validationErrors > 1 ? 's' : ''} before saving.`;
      } else {
        validationSummary.textContent = '';
      }

      return !hasValidationErrors;
    }

    function updateTotals() {
      const filteredEmployees = employeeData.filter(employee =>
        employee.homeDepartment === currentDepartment
      );



      // Calculate total allocated to home department
      let totalAllocated = 0;
      let totalSalary = 0;
      let totalSalaryWithFringe = 0;
      let totalCore = 0;

      filteredEmployees.forEach(employee => {
        let employeeTotal = 0;
        employee.allocations.forEach(allocation => {
          totalSalary += allocation.monthlyValues.reduce((sum, val) => sum + val, 0);
          const fringeRate = budgetData.metadata.fringe_rates.find(rate =>
            rate.domicile === (employee.domicile || 'TBD')
          )?.rate || 0.41; // Default to 0.41 if no rate found

          totalSalaryWithFringe += allocation.monthlyValues.reduce((sum, val) => sum + val, 0) * (1 + fringeRate);

          if (allocation.department === currentDepartment) {
            // Sum the monthly values for each allocation
            const allocationTotal = allocation.monthlyValues.reduce((sum, val) => sum + val, 0) * (1 + fringeRate);
            totalAllocated += allocationTotal;
            totalCore += (allocationTotal * (allocation.percentCore / 100));
          }

          // Update the total for each allocation line
          const totalValue = allocation.monthlyValues.reduce((sum, val) => sum + val, 0);
          const totalCell = document.getElementById(`linetotal-${allocation.id}`);
          if (totalCell) {
            totalCell.textContent = formatCurrency(totalValue, currentCurrency);
          }

          // Add to employee's total
          employeeTotal += totalValue;
        });

        // Update the grand total for the employee
        const grandTotalCell = document.getElementById(`grandtotal-${employee.id}`);
        if (grandTotalCell) {
          grandTotalCell.textContent = `${formatCurrency(employeeTotal, currentCurrency)}`;
        }
      });



      // Update flexible expenses total
      const flexibleTotal = flexibleExpensesData
        .filter(exp => exp.department === currentDepartment)
        .reduce((sum, exp) => sum + exp.monthlyValues.reduce((monthSum, val) => monthSum + val, 0), 0);


      document.getElementById('total-salaries').textContent = formatCurrency(Math.round(totalSalary), currentCurrency);
      document.getElementById('total-allocated').textContent = formatCurrency(Math.round(totalAllocated), currentCurrency);
      document.getElementById('total-allocated2').textContent = formatCurrency(Math.round(totalAllocated), currentCurrency);
      document.getElementById('total-allocated-core').textContent = formatCurrency(Math.round(totalCore), currentCurrency);
      document.getElementById('total-salaries-with-fringe').textContent = formatCurrency(Math.round(totalSalaryWithFringe), currentCurrency);
      document.getElementById('total-flexible-expenses').textContent = formatCurrency(Math.round(flexibleTotal), currentCurrency);
      document.getElementById('grand-total').textContent = formatCurrency(Math.round(totalAllocated + flexibleTotal), currentCurrency);
    }


    function createGrandTotalRow(employee) {
      const grandTotalRow = document.createElement('div');
      grandTotalRow.className = 'allocation-line grand-total-value';

      // Empty cells to align with the structure of allocation lines
      for (let i = 0; i < 16; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.textContent = ''; // Keeps the structure aligned
        grandTotalRow.appendChild(emptyCell);
      }

      // Calculate the grand total of all allocations
      const grandTotalValue = employee.allocations.reduce((sum, allocation) => {
        return sum + allocation.monthlyValues.reduce((subSum, val) => subSum + val, 0);
      }, 0);

      // Grand total cell
      const grandTotalCell = document.createElement('div');
      grandTotalCell.textContent = formatCurrency(grandTotalValue, currentCurrency);
      grandTotalCell.id = `grandtotal-${employee.id}`;
      grandTotalRow.appendChild(grandTotalCell);

      return grandTotalRow;
    }



    function saveData() {
      if (hasValidationErrors) {
        alert('Please fix all validation errors before saving.');
        return;
      }

      // Find current iteration and update its employee data
      const iterationIndex = budgetData.iterations.findIndex(iter => iter.iterationId === currentIteration);
      if (iterationIndex === -1) {
        alert('Cannot find the current iteration to save.');
        return;
      }
      // Update the employee and account data in the budget data structure
      budgetData.iterations[iterationIndex].employees = employeeData;

      budgetData.iterations[iterationIndex].flexibleExpenses = flexibleExpensesData;

      // In a real application, this would post data to an API endpoint
      const dataToSave = {
        iterationId: currentIteration,
        timestamp: new Date().toISOString(),
        employees: employeeData,
        flexibleExpenses: flexibleExpensesData
      };

      // Simulate API call
      console.log('Saving data:', dataToSave);
      alert(`Data for iteration ${currentIteration} saved successfully.`);
    }

    // Helper functions
    function findEmployee(id) {
      return employeeData.find(employee => employee.id === id);
    }

    function generateMonthlyValues(newSalary, salaryOld, salaryChangeMonth, percent, currency) {
      if (currentCurrency != currency) {
        const fx_rate = fx_rates.find(rate => rate.from === currency && rate.to === currentCurrency);
        newSalary = newSalary * fx_rate.rate;
        salaryOld = salaryOld * fx_rate.rate;
      }

      const totalAmountold = salaryOld * (percent / 100);
      const totalAmountNew = newSalary * (percent / 100);
      const baseMonthlyAmountOld = totalAmountold / 12;
      const baseMonthlyAmountNew = totalAmountNew / 12;
      const roundedValues = []; // Initialize empty array
      let sumNewValues = 0;

      // Use standard array assignment
      for (let i = 0; i < 11; i++) {
        if (i < salaryChangeMonth) {
          roundedValues[i] = Math.round(baseMonthlyAmountOld);
        } else {
          roundedValues[i] = Math.round(baseMonthlyAmountNew);
          sumNewValues += Math.round(baseMonthlyAmountNew);
        }
      }

      // Add the final month
      roundedValues[11] = Math.round(baseMonthlyAmountNew * (12 - salaryChangeMonth)) - sumNewValues;

      return roundedValues;
    }

    function formatCurrency(amount, currency) {
      const numberFormat = new Intl.NumberFormat();
      switch (currency || 'USD') {
        case 'USD':
          return '$' + numberFormat.format(amount);
        case 'GBP':
          return '£' + numberFormat.format(amount); // Use the correct GBP symbol
        case 'EUR':
          return '€' + numberFormat.format(amount); // Use the correct EUR symbol      
        default:
          return numberFormat.format(amount); // Just format the number if no currency is set
      }
    }

    function displayCurrency() {
      //const department = departments.find(dept => dept.value === currentDepartment);
      const currencyDisplay = document.getElementById('currency-display');
      currencyDisplay.innerHTML = 'This department is budgeting in: <span class="bold-currency">' + currentCurrency + '</span>';
    }


  });
</script>
</body>

</html>