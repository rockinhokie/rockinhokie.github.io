<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Department Budget Allocation</title>
  <style>
    :root {
      --primary-color: #3f51b5;
      --secondary-color: #f5f5f5;
      --accent-color: #ff4081;
      --text-color: #333;
      --light-gray: #e0e0e0;
      --danger-color: #f44336;
      --danger-bg: #ffebee;
      --success-color: #4caf50;
    }

    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      margin: 0;
      padding: 20px;
      background-color: #f9f9f9;
      color: var(--text-color);
      min-width: 1400px;
      /* Prevent wrapping on small screens */
    }

    .container {
      max-width: 1500px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      overflow-x: auto;
      /* Allow horizontal scrolling */
    }

    h1 {
      color: var(--primary-color);
      margin-top: 0;
      margin-bottom: 20px;
      font-weight: 500;
    }

    .header-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--light-gray);
    }

    .filters select {
      padding: 8px 12px;
      border: 1px solid var(--light-gray);
      border-radius: 4px;
      margin-right: 10px;
      font-size: 14px;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #303f9f;
    }

    button:disabled {
      background-color: #9e9e9e;
      cursor: not-allowed;
    }

    button.danger {
      background-color: var(--danger-color);
      margin-top: auto;
      /* Pushes button to the bottom */
      align-self: flex-end;
      /* Aligns button to the right */
      width: 150px;
    }

    button.save {
      background-color: var(--success-color);
    }

    button.danger:hover {
      background-color: #d32f2f;
    }

    button.save:hover {
      background-color: #45a049;
    }

    .tab-container {
      margin: 20px 0;
      border-bottom: 2px solid var(--light-gray);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #currency-display {
      font-size: 16px;
      padding: 10px;
      align-items: center;
      /* Vertically align items in the middle */
      justify-content: center;
      /* Horizontally align items in the middle (optional) */
    }

    .bold-currency {
      font-weight: bold;
    }

    #add-employee-btn {
      display: none;
      /* Hidden by default */
    }

    .tab-container.staff-active #add-employee-btn {
      display: block;
    }

    .tabs {
      display: flex;
      gap: 2px;
    }

    .tab {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      background-color: #999;
      border: none;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      min-width: 200px;
    }

    .tab.active {
      background-color: var(--primary-color);
      color: white;
    }

    .tab-content {
      display: none;
      padding: 20px 0;
    }

    .tab-content.active {
      display: block;
    }

    .employee-box {
      border-radius: 8px;
      margin-bottom: 10px;
      padding: 10px;
      background-color: f5f5f5;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      transition: border-color 0.3s;
    }

    .employee-box:nth-child(odd) {
      border: 1px solid var(--light-gray);
    }

    .employee-box:nth-child(even) {
      border: 1px solid #bdbdbd;
    }

    .employee-box.error {
      border-color: var(--danger-color);
      background-color: var(--danger-bg);
    }
/*
    .employee-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
*/
    .employee-info {
      display: grid;
      grid-template-columns: 1fr 1fr 150px 150px 150px 100px 150px;
      gap: 15px;
      margin-bottom: 15px;
    }

    .employee-info .field-group {
      display: flex;
      flex-direction: column;
    }


    .field-group label {
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
    }

    .field-group input {
      padding: 8px;
      border: 1px solid var(--light-gray);
      border-radius: 4px;
      font-size: 14px;
    }

    .field-group input:disabled {
      background-color: var(--secondary-color);
      cursor: not-allowed;
    }

    .column-headers {
      display: grid;
      grid-template-columns: 30px 80px 250px 80px repeat(13, 65px);
      gap: 5px;
      margin-bottom: 10px;
      font-weight: 500;
      font-size: 13px;
      color: #555;
      padding: 1 1px;
      width: 100%;
      /* Fixed width to prevent wrapping */
      justify-items: center;
      text-align: center;
    }

    .column-headers button.add-line {
      width: 24px;
      height: 24px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      background-color: var(--primary-color);
      color: white;
    }

    .column-headers button.add-line:hover {
      background-color: #303f9f;
    }

    .allocation-line {
      display: grid;
      grid-template-columns: 30px 80px 250px 80px repeat(13, 65px);
      gap: 5px;
      margin-bottom: 1px;
      justify-items: center;
      text-align: center;
      padding: 1px 1px;
      border-radius: 4px;
      background-color: var(--secondary-color);
      width: 100%;
      /* Fixed width to prevent wrapping */
    }


    .allocation-line button.delete-line {
      width: 24px;
      height: 24px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      background-color: transparent;
      color: #999;
    }

    .allocation-line button.delete-line:hover {
      color: var(--danger-color);
    }

    .allocation-line select,
    .allocation-line input {
      padding: 3px;
      border: 1px solid var(--light-gray);
      border-radius: 4px;
      font-size: 13px;
      width: 100%;
    }


    .grand-total-value div {
      grid-template-columns: 30px 80px 200px;
      font-size: 12px;
      font-weight: bold;
      text-decoration: underline;
      color: var(--text-color);
      background-color: var(--secondary-color);
      text-align: right;
      padding: 5px;
    }



    .grand-total-value div:last-child {
      font-weight: bold;
      padding-right: 10px;
    }


    .allocation-line input.monthly-input {
      text-align: right;
    }

    .justification-value {
      display: grid;
      grid-template-columns: 200px 1fr;
      /* Label and Input */
      align-items: center;
      margin-bottom: 5px;
      padding: 5px;
    }

    .justification-value label {
      text-align: right;
      padding-right: 10px;
      font-weight: bold;
    }

    .justification-value input {
      width: 100%;
      /* Make the input take up the remaining space */
      padding: 8px;
      border: 1px solid var(--light-gray);
      border-radius: 4px;
      font-size: 14px;
    }



    .total-value {
      font-size: 12px;
      font-weight: bold;
      color: var(--text-color);
      text-align: right;
      padding: 5px;
      border-radius: 4px;
      background-color: var(--secondary-color);
    }

/*
    .allocation-actions {
      margin-top: 15px;
      display: flex;
      justify-content: flex-end;
    }
*/
    .error-message {
      color: var(--danger-color);
      font-size: 13px;
      margin-top: 10px;
    }

    .newemployee-bottom {
      text-align: right;
    }

    .grand-total {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 2px solid var(--light-gray);
    }

    .grand-total-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .grand-total-row span:first-child {
      font-weight: 500;
    }

    .grand-total-row span:last-child {
      font-size: 18px;
      color: var(--primary-color);
    }

    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 200px;
    }

    .error-text {
      color: var(--danger-color);
    }

    .save-section {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 2px solid var(--light-gray);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .save-info {
      color: #666;
      font-size: 14px;
    }

    .validation-summary {
      color: var(--danger-color);
      font-size: 14px;
      margin-right: 20px;
    }

    #flexible-expenses {
  display: flex;
  flex-direction: column;
}

.newexpense-bottom {
  text-align: right;
  margin-top: 20px;
}

#flexible-expenses .column-headers,
#flexible-expenses .allocation-line {
    grid-template-columns: minmax(200px, 1fr) 30px 75px 100px repeat(12, 70px) 75px 75px;
}

    /* Add class for when spend-to-date column is present */
#flexible-expenses .column-headers.has-actuals,
#flexible-expenses .allocation-line.has-actuals {
    grid-template-columns: minmax(200px, 1fr) 30px 75px 100px repeat(var(--actual-months, 12), 75px) 75px repeat(var(--remaining-months, 0), 70px) 75px;
}

    #flexible-expenses .column-headers div {
      padding: 8px 0;
      /* Remove background-color from here */
    }


    #flexible-expenses .allocation-line:nth-child(even) {
      background-color: white;
    }

    #flexible-expenses .allocation-line:nth-child(odd) {
      background-color: var(--secondary-color);
    }

    
  </style>
</head>

<body>
  <div class="container">
    <h1>Department Budget Allocation</h1>

    <div class="header-controls">
      <div class="filters">
        <label for="department-filter">Home Department:</label>
        <select id="department-filter">
        </select>

        <label for="iteration-filter">Budget Iteration:</label>
        <select id="iteration-filter">
          <option value="FY25" selected>FY25 (Board Approved)</option>
          <option value="FY25-Q1">FY25-Q1 (Q1 Update)</option>
          <option value="FY25-Q2">FY25-Q2 (Q2 Update)</option>
        </select>
      </div>


    </div>

    <div class="tab-container">
      <div class="tabs">
        <button class="tab active" data-tab="staff">Staff Expenses</button>
        <button class="tab" data-tab="flexible">Flexible Expenses</button>
        <div id="currency-display"></div>
      </div>
      <button id="add-employee-btn" type="button">+ Add New Employee</button>
    </div>
    <div id="staff-container" class="tab-content active">

      <!-- Existing employee containers move here -->
      <div id="employee-containers">
        <!-- Employees will be loaded here dynamically -->
        <div class="loading">Loading employee data...</div>
      </div>
      <div class="newemployee-bottom">
        <button id="add-employee-btn2" type="button">+ Add New Employee</button>
      </div>
      <div class="grand-total">

        <div class="grand-total-row">
          <span>Total Salaries:</span>
          <span id="total-salaries">$0.00</span>
        </div>
        <div class="grand-total-row">
          <span>Total Allocated to Home Department:</span>
          <span id="total-allocated">$0.00</span>
        </div>
        <div class="grand-total-row">
          <span>Total Allocated to Home Department / Core Fund:</span>
          <span id="total-allocated-core">$0.00</span>
        </div>
      </div>





    </div>
    <div id="flexible-container" class="tab-content">
      <!-- New flexible expenses content will go here -->
      <div id="flexible-expenses"></div>
    </div>
    <div class="save-section">
      <div>
        <div class="save-info">All changes will be saved to the current iteration: <span
            id="current-iteration-display">FY25</span></div>
        <div id="validation-summary" class="validation-summary"></div>
      </div>
      <button id="save-btn" type="button" class="save">Save Budget Data</button>
    </div>
  </div>
</body>


<script>
  // Replace the script section in index2.html with this updated version
  document.addEventListener('DOMContentLoaded', function () {
    // Global variables
    let budgetData = null;
    let employeeData = [];
    let flexibleExpensesData = [];
    let departments = [];
    let fx_rates = [];
    let expense_accounts = [];
    let currentDepartment = '';
    let currentIteration = 'FY25';
    let currentCurrency = '';
    let hasValidationErrors = false;
    let availableIterations = [];

    // Initialize the application
    init();

    async function init() {
      try {
        await fetchBudgetData();
        setupEventListeners();
        setupMonthlyValueListeners(); // Move this here
        loadIterationData(currentIteration);
        updateIterationUI();
        renderEmployees();
        renderExpenses();
        updateTotals();
        validateAllEmployees();
        document.querySelector('.tab-container').classList.add('staff-active');
      } catch (error) {
        console.error('Failed to initialize application:', error);
        document.getElementById('employee-containers').innerHTML =
          `<div class="error-text">Failed to load employee data. Please try again.</div>`;
        document.getElementById('flexible-container').innerHTML =
          `<div class="error-text">Failed to load account data. Please try again.</div>`;
      }
    }


    function setupMonthlyValueListeners() {
    // Listen for expenses
    const expenseContainer = document.getElementById('flexible-expenses');
    expenseContainer.addEventListener('blur', handleContainerBlur, true);

    // Listen for employee values
    const employeeContainer = document.getElementById('employee-containers');
    employeeContainer.addEventListener('blur', handleContainerBlur, true);
}

function handleContainerBlur(e) {
    if (!e.target.classList.contains('monthly-input')) return;

    const input = e.target;
    const line = input.closest('.allocation-line');
    const monthIndex = parseInt(input.dataset.monthIndex);

    if (e.currentTarget.id === 'flexible-expenses') {
        // Handle flexible expense monthly values
        const accountIndex = parseInt(line.dataset.accountIndex);
        handleMonthlyValue(input, input.dataset.originalValue || 0, currentCurrency, (newValue) => {
            const account = expense_accounts[accountIndex];
            let expenseData = flexibleExpensesData.find(exp =>
                exp.account === account.id && 
                exp.department === currentDepartment
            );

            if (!expenseData) {
                expenseData = {
                    account: account.id,
                    department: currentDepartment,
                    monthlyValues: Array(12).fill(0)
                };
                flexibleExpensesData.push(expenseData);
            }

            // Update the value in the monthlyValues array
            expenseData.monthlyValues[monthIndex] = newValue;
            input.dataset.originalValue = newValue;

            // Recalculate spend-to-date total
            let spendToDateTotal = 0;
            let lastActualMonth = -1;

            // Find last month with actuals across all accounts
            flexibleExpensesData.forEach(exp => {
                if (exp.actualMonthlyValues) {
                    exp.actualMonthlyValues.forEach((value, idx) => {
                        if (value !== null && value !== undefined) {
                            lastActualMonth = Math.max(lastActualMonth, idx);
                        }
                    });
                }
            });

            // Calculate spend to date (sum of all values up to lastActualMonth)
            if (lastActualMonth >= 0) {
                for (let i = 0; i <= lastActualMonth; i++) {
                    spendToDateTotal += expenseData.monthlyValues[i] || 0;
                }
                
                // Update spend to date cell
                const spendToDateCell = line.querySelector('.spend-to-date');
                if (spendToDateCell) {
                    spendToDateCell.textContent = formatCurrency(spendToDateTotal, currentCurrency);
                }
            }

            // Update line total
            const totalCell = line.querySelector('.total-value:last-child');
            const grandTotal = expenseData.monthlyValues.reduce((sum, val) => sum + (val || 0), 0);
            if (totalCell) {
                totalCell.textContent = formatCurrency(grandTotal, currentCurrency);
            }

            updateTotals();
        });
    } else if (e.currentTarget.id === 'employee-containers') {
        // Handle employee allocation monthly values
        const allocationId = parseInt(line.dataset.allocationId);
        const employeeId = parseInt(line.closest('.employee-box').dataset.employeeId);
        const employee = findEmployee(employeeId);
        if (!employee) return;

        const allocation = employee.allocations.find(a => a.id === allocationId);
        if (!allocation) return;

        handleMonthlyValue(input, input.dataset.originalValue || 0, currentCurrency, (newValue) => {
            allocation.monthlyValues[monthIndex] = newValue;
            input.dataset.originalValue = newValue;

            // Update line total
            const totalCell = line.querySelector('.total-value:last-child');
            const totalValue = allocation.monthlyValues.reduce((sum, val) => sum + (val || 0), 0);
            if (totalCell) {
                totalCell.textContent = formatCurrency(totalValue, currentCurrency);
            }

            updateTotals();
        });
    }
}

    async function fetchBudgetData() {
      try {
        // In a real application, this would be a fetch call to an API endpoint
        // For this example, we'll simulate fetching the data
        const response = await fetch('budget-data.json');
        if (!response.ok) {
          throw new Error('Failed to fetch budget data');
        }
        budgetData = await response.json();

        // Extract available iterations from metadata
        availableIterations = budgetData.metadata.availableIterations;

        // Extract available fx rates from metadata
        fx_rates = budgetData.metadata.fx_rates;        // Extract departments from budgetData

        departments = budgetData.departments.sort((a, b) => a.value.localeCompare(b.value));

        expense_accounts = budgetData.metadata.expense_accounts;

        // Set the currentDepartment to the first department value
        if (departments.length > 0) {
          currentDepartment = departments[0].value;
          const selectedDepartment = departments.find(dept => dept.value === currentDepartment);
          currentCurrency = selectedDepartment ? selectedDepartment.currency : '';
        }

        // Populate iteration dropdown
        const iterationDropdown = document.getElementById('iteration-filter');
        iterationDropdown.innerHTML = '';
        availableIterations.forEach(iteration => {
          const option = document.createElement('option');
          option.value = iteration.id;
          option.textContent = iteration.name;
          if (iteration.id === currentIteration) {
            option.selected = true;
          }
          iterationDropdown.appendChild(option);
        });

        // Populate department dropdown
        const departmentDropdown = document.getElementById('department-filter');
        departmentDropdown.innerHTML = '';
        departments.forEach(dept => {
          const option = document.createElement('option');
          option.value = dept.value;
          option.textContent = dept.label;
          if (dept.value === currentDepartment) {
            option.selected = true;
          }
          departmentDropdown.appendChild(option);
        });

        displayCurrency();

      } catch (error) {
        console.error('Failed to fetch budget data:', error);
        throw error;
      }
    }

    function loadIterationData(iterationId) {
      const iteration = budgetData.iterations.find(iter => iter.iterationId === iterationId);
      if (!iteration) {
        console.error(`Iteration with ID ${iterationId} not found`);
        return;
      }

      employeeData = iteration.employees.map(employee => {
        // Initialize fields that we aren't getting from the DB/JSON
        employee.salaryOld = employee.salary;
        employee.salaryChangeMonth = 0;
        employee.currency = employee.currency || currentCurrency;
        employee.isExisting = true;

        // If the employee has no allocations, create a default one
        if (!employee.allocations || employee.allocations.length === 0) {
          employee.allocations = [{
            id: Date.now() + 1, // Another temporary ID
            department: currentDepartment,
            percent: 100,
            percentCore: 100,
            monthlyValues: generateMonthlyValues(employee.salary, employee.salaryOld, employee.salaryChangeMonth, 100, employee.currency)
          }];
        }

        // Ensure that each iteration has a flexibleExpenses array
        budgetData.iterations.forEach(iteration => {
          if (!iteration.flexibleExpenses) {
            iteration.flexibleExpenses = [];
          }
        });

        return employee;
      });

      flexibleExpensesData = iteration.flexibleExpenses.map(expense => ({
        account: expense.account,
        department: expense.department,
        monthlyValues: [...expense.monthlyValues],
        actualMonthlyValues: expense.actualMonthlyValues ? [...expense.actualMonthlyValues] : [],
        totalAllocation: expense.totalAllocation,
        allocationType: expense.allocationType,
        CustomName: expense.CustomName,
        investmentRequest: expense.investmentRequest
    }));
      currentIteration = iterationId;
    }

    function updateIterationUI() {
      document.getElementById('current-iteration-display').textContent =
        availableIterations.find(iter => iter.id === currentIteration)?.name || currentIteration;
    }

    function setupEventListeners() {
      // Department filter change event
      document.getElementById('department-filter').addEventListener('change', function (e) {
        currentDepartment = e.target.value;
        const selectedDepartment = departments.find(dept => dept.value === currentDepartment);
        currentCurrency = selectedDepartment ? selectedDepartment.currency : '';
        renderEmployees();
        renderExpenses();
        updateTotals();
        validateAllEmployees();
        displayCurrency();
      });

      // Iteration filter change event
      document.getElementById('iteration-filter').addEventListener('change', function (e) {
        currentIteration = e.target.value;
        loadIterationData(currentIteration);
        updateIterationUI();
        renderEmployees();
        renderExpenses();
        updateTotals();
        validateAllEmployees();
      });

      // Add event listener for both add-employee-btn (top of page) and add-employee-btn2 (bottom of page)
      document.querySelectorAll('#add-employee-btn, #add-employee-btn2').forEach(button => {
        button.addEventListener('click', () => {
          addNewEmployee();
          window.scrollTo({
            top: document.body.scrollHeight, // Scroll to the bottom
            behavior: "smooth"               // Smooth scroll
          });
        });
      });


      // Save button
      document.getElementById('save-btn').addEventListener('click', saveData);

      // Add tab switching functionality
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          // Remove active class from all tabs and content
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

          // Add active class to clicked tab and corresponding content
          tab.classList.add('active');
          const tabContent = document.getElementById(`${tab.dataset.tab}-container`);
          tabContent.classList.add('active');

          // Update tab container class based on active tab
          const tabContainer = document.querySelector('.tab-container');
          if (tab.dataset.tab === 'staff') {
            tabContainer.classList.add('staff-active');
          } else {
            tabContainer.classList.remove('staff-active');
          }
        });
      });
    }


    function renderEmployees() {
      const container = document.getElementById('employee-containers');
      container.innerHTML = '';
      // Filter employees by home department
      const filteredEmployees = employeeData.filter(employee =>
        employee.homeDepartment === currentDepartment
      );

      if (filteredEmployees.length === 0) {
        container.innerHTML = '<div class="loading">No employees found for the selected department.</div>';
        return;
      }

      filteredEmployees.forEach(employee => {
        container.appendChild(createEmployeeBox(employee));
      });
    }


    function renderExpenses() {
      const ExpContainer = document.getElementById('flexible-expenses');
      ExpContainer.innerHTML = '';

      // Create a wrapper for the entire content
      const wrapper = document.createElement('div');
      wrapper.className = 'expenses-wrapper';

     // Determine last month with actuals first
    let lastActualMonth = -1;
    flexibleExpensesData.forEach(exp => {
        if (exp.actualMonthlyValues) {
            exp.actualMonthlyValues.forEach((value, monthIndex) => {
                if (value !== null && value !== undefined) {
                    lastActualMonth = Math.max(lastActualMonth, monthIndex);
                }
            });
        }
    });

    // Create headers array
    const baseHeaders = [
        'Account Name', 
        'Invest Req?',
        'Total Alloc', 
        'Alloc Type'
    ];

    const monthHeaders = [
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 
        'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'
    ];

    // Build complete headers array with Spend to Date in correct position
    let columnTitles = [...baseHeaders];
    for (let i = 0; i < monthHeaders.length; i++) {
        columnTitles.push(monthHeaders[i]);
        if (i === lastActualMonth && lastActualMonth >= 0) {
            columnTitles.push('Spend to Date');
        }
    }
    columnTitles.push('Total');

    // Create header elements
    const headers = document.createElement('div');
    headers.className = 'column-headers';
    columnTitles.forEach(title => {
        const div = document.createElement('div');
        div.textContent = title;
        headers.appendChild(div);
    });

    wrapper.appendChild(headers);

      // Add account lines
      expense_accounts.forEach((account, index) => {

        let expenseData = flexibleExpensesData.find(exp =>
          exp.account === account.id && exp.department === currentDepartment
        );

        if (!expenseData) {
          expenseData = {
            account: account.id,
            department: currentDepartment,
            monthlyValues: Array(12).fill(0)
          };
          flexibleExpensesData.push(expenseData);
        }

        const accountLine = createAccountLine(account, expenseData, index);
        wrapper.appendChild(accountLine);
      });

      ExpContainer.appendChild(wrapper);

     const grandTotal = document.createElement('div');
  grandTotal.className = 'grand-total';
  
  const totalRow = document.createElement('div');
  totalRow.className = 'grand-total-row';
  
  const totalLabel = document.createElement('span');
  totalLabel.textContent = 'Total Flexible Expenses:';
  
  const totalAmount = document.createElement('span');
  totalAmount.id = 'total-flexible-expenses';
  
  // Calculate total of all flexible expenses
  const total = flexibleExpensesData
    .filter(exp => exp.department === currentDepartment)
    .reduce((sum, exp) => sum + exp.monthlyValues.reduce((monthSum, val) => monthSum + val, 0), 0);
  
  totalAmount.textContent = formatCurrency(total, currentCurrency);
  
  totalRow.appendChild(totalLabel);
  totalRow.appendChild(totalAmount);
  grandTotal.appendChild(totalRow);
  
  ExpContainer.appendChild(grandTotal);

  // Add bottom section for new expense button
  const bottomSection = document.createElement('div');
  bottomSection.className = 'newexpense-bottom';
  
  const addAccountBtn2 = document.createElement('button');
  addAccountBtn2.textContent = '+ Add Investments or Other Expenses';
  addAccountBtn2.type = 'button';
  addAccountBtn2.addEventListener('click', addNewAccount);
  
  bottomSection.appendChild(addAccountBtn2);
  ExpContainer.appendChild(bottomSection);
    }
    
    function addNewAccount() {
    const newAccount = {
        id: "custom",
        Name: "",
        CustomName: "Enter Investment/Expense Description", // This will be updated when user types
        Type: "Expense",
        Category: "Operating Expenses",
        Subcategory: "Other"
    };

    expense_accounts.push(newAccount);
    
    // Create corresponding expense data with CustomName
    const newExpenseData = {
        account: newAccount.id,
        department: currentDepartment,
        monthlyValues: Array(12).fill(0),
        CustomName: newAccount.CustomName,  // Add CustomName to expense data
        investmentRequest: false  // Add investment request field
    };
    flexibleExpensesData.push(newExpenseData);

    renderExpenses();
}

function getLastActualMonth() {
    let lastActualMonth = -1;
    flexibleExpensesData.forEach(exp => {
        if (exp.actualMonthlyValues) {
            exp.actualMonthlyValues.forEach((value, idx) => {
                if (value !== null && value !== undefined) {
                    lastActualMonth = Math.max(lastActualMonth, idx);
                }
            });
        }
    });
    return lastActualMonth;
}

function findExpenseData(accountId, department) {
    return flexibleExpensesData.find(exp => 
        exp.account === accountId && 
        exp.department === department
    );
}

function createAccountLine(account, expenseData, index) {
    const line = document.createElement('div');
    line.className = 'allocation-line';
    line.dataset.accountIndex = index;

    // Find last month with actuals first
    const monthsWithActuals = new Set();
    let lastActualMonth = -1;
    flexibleExpensesData.forEach(exp => {
        if (exp.actualMonthlyValues) {
            exp.actualMonthlyValues.forEach((value, monthIndex) => {
                if (value !== null && value !== undefined) {
                    monthsWithActuals.add(monthIndex);
                    lastActualMonth = Math.max(lastActualMonth, monthIndex);
                }
            });
        }
    });

    // Account Name handling
    if (account.id === "custom") {
    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.className = 'account-name-input';
    nameInput.value = expenseData.CustomName || account.CustomName || '';
    nameInput.placeholder = 'Enter Investment/Expense Description';
    nameInput.addEventListener('blur', e => {
        const newName = e.target.value;
        account.CustomName = newName;
        account.Name = newName;
        expenseData.CustomName = newName; // Save to expense data
        
        // Update the corresponding flexible expense data
        const expenseIndex = flexibleExpensesData.findIndex(exp => 
            exp.account === account.id && 
            exp.department === currentDepartment
        );
        if (expenseIndex !== -1) {
            flexibleExpensesData[expenseIndex].CustomName = newName;
        }
    });
    line.appendChild(nameInput);
}else {
        const nameDiv = document.createElement('div');
        nameDiv.textContent = account.Name;
        line.appendChild(nameDiv);
    }
    
    if (account.id === "custom") {
    const investmentCell = document.createElement('div');
    const investmentCheckbox = document.createElement('input');
    investmentCheckbox.type = 'checkbox';
    investmentCheckbox.checked = expenseData.investmentRequest || false;
    investmentCheckbox.addEventListener('change', e => {
        // Update the expenseData directly
        expenseData.investmentRequest = e.target.checked;
        
        // Find and update in flexibleExpensesData array
        const expenseIndex = flexibleExpensesData.findIndex(exp => 
            exp.account === account.id && 
            exp.department === currentDepartment
        );
        if (expenseIndex !== -1) {
            flexibleExpensesData[expenseIndex].investmentRequest = e.target.checked;
        }
    });
    investmentCell.appendChild(investmentCheckbox);
    line.appendChild(investmentCell);
} else {
    // Add empty cell for non-custom expenses
    const emptyCell = document.createElement('div');
    line.appendChild(emptyCell);
}

    // Total Allocation Input
    const totalAllocInput = document.createElement('input');
    totalAllocInput.type = 'text';
    totalAllocInput.className = 'total-alloc-input';
    totalAllocInput.value = formatCurrency(expenseData.totalAllocation || 0, currentCurrency);
    totalAllocInput.addEventListener('blur', e => {
    handleMonthlyValue(e.target, expenseData.totalAllocation || 0, currentCurrency, (newValue) => {
        expenseData.totalAllocation = newValue;
        distributeAllocation(expenseData, line);
    });
});
    line.appendChild(totalAllocInput);

    // Create allocation type dropdown using the same lastActualMonth
    // In createAccountLine function, update the allocation types check:
const availableAllocTypes = [
    { value: 'straight-line', label: 'Straight Line' }
];

// Check if quarters are still available
const q1Available = getAvailableMonths(0, 2).length > 0;
const q2Available = getAvailableMonths(3, 5).length > 0;
const q3Available = getAvailableMonths(6, 8).length > 0;
const q4Available = getAvailableMonths(9, 11).length > 0;

if (q1Available) availableAllocTypes.push({ value: 'q1', label: 'Q1 Only (Jul-Sep)' });
if (q2Available) availableAllocTypes.push({ value: 'q2', label: 'Q2 Only (Oct-Dec)' });
if (q3Available) availableAllocTypes.push({ value: 'q3', label: 'Q3 Only (Jan-Mar)' });
if (q4Available) availableAllocTypes.push({ value: 'q4', label: 'Q4 Only (Apr-Jun)' });

// Check if halves are still available
const firstHalfAvailable = getAvailableMonths(0, 5).length > 0;
const secondHalfAvailable = getAvailableMonths(6, 11).length > 0;

if (firstHalfAvailable) availableAllocTypes.push({ value: 'first-half', label: '1H FY (Jul-Dec)' });
if (secondHalfAvailable) availableAllocTypes.push({ value: 'second-half', label: '2H FY (Jan-Jun)' });
    // Create allocation type dropdown with only available options
    const allocTypeSelect = document.createElement('select');
    allocTypeSelect.className = 'alloc-type-select';
    availableAllocTypes.forEach(type => {
        const option = document.createElement('option');
        option.value = type.value;
        option.textContent = type.label;
        if (type.value === (expenseData.allocationType || 'straight-line')) {
            option.selected = true;
        }
        allocTypeSelect.appendChild(option);
    });

    allocTypeSelect.addEventListener('change', e => {
        expenseData.allocationType = e.target.value;
        distributeAllocation(expenseData, line);
    });
    line.appendChild(allocTypeSelect);

  
    // Monthly values container
    const monthlyContainer = document.createElement('div');
    monthlyContainer.className = 'monthly-values';
    
     // Monthly inputs
     let spendToDateTotal = 0;  // Only for actual values
    let grandTotal = 0;        // For all values
    
    for (let i = 0; i < 12; i++) {
        const monthInput = document.createElement('input');
        monthInput.type = 'text';
        monthInput.className = 'monthly-input';
        
        const hasAccountActual = expenseData.actualMonthlyValues && 
                               i < expenseData.actualMonthlyValues.length && 
                               expenseData.actualMonthlyValues[i] !== null;
        
        const isMonthLocked = monthsWithActuals.has(i);
        
        if (hasAccountActual || isMonthLocked) {
            // Use actual value if available, otherwise use planned value for locked months
            const value = hasAccountActual ? expenseData.actualMonthlyValues[i] : 
                                          expenseData.monthlyValues[i] || 0;
            monthInput.value = formatCurrency(value, currentCurrency);
            monthInput.disabled = true;
            monthInput.classList.add(hasAccountActual ? 'actual-value' : 'locked-month');
            expenseData.monthlyValues[i] = value;
            spendToDateTotal += value;  // Add to spend-to-date total
            grandTotal += value;        // Also add to grand total
        } else {
            const plannedValue = expenseData.monthlyValues[i] || 0;
            monthInput.value = formatCurrency(plannedValue, currentCurrency);
            monthInput.dataset.monthIndex = i;
            monthInput.dataset.originalValue = plannedValue;
            grandTotal += plannedValue;  // Only add to grand total
        }
        
        line.appendChild(monthInput);

        // Add Spend to Date column after last actual month
        if (i === lastActualMonth && lastActualMonth >= 0) {
            const spendToDateCell = document.createElement('div');
            spendToDateCell.className = 'monthly-input total-value spend-to-date';
            spendToDateCell.textContent = formatCurrency(spendToDateTotal, currentCurrency);
            line.appendChild(spendToDateCell);
        }
    }

    // Total cell (all values)
    const totalCell = document.createElement('div');
    totalCell.className = 'monthly-input total-value';
    totalCell.textContent = formatCurrency(grandTotal, currentCurrency);
    line.appendChild(totalCell);

    return line;
}


function getAvailableMonths(start, end) {
    const lastActualMonth = getLastActualMonth();
    let months = [];
    for (let i = Math.max(start, lastActualMonth + 1); i <= end; i++) {
        months.push(i);
    }
    return months;
}

function distributeAllocation(expenseData, line) {
    const total = expenseData.totalAllocation || 0;
    const type = expenseData.allocationType || 'straight-line';
    
    // Use the helper to get lastActualMonth
    let lastActualMonth = getLastActualMonth();

    // Calculate spend to date
    let spendToDate = 0;
    for (let i = 0; i <= lastActualMonth; i++) {
        if (expenseData.actualMonthlyValues && expenseData.actualMonthlyValues[i] !== null) {
            spendToDate += expenseData.actualMonthlyValues[i];
        } else if (expenseData.monthlyValues[i]) {
            spendToDate += expenseData.monthlyValues[i];
        }
    }
    
    const remainingTotal = total - spendToDate;
    const startMonth = lastActualMonth + 1;
    const newMonthlyValues = [...expenseData.monthlyValues];

    // Clear future values first
    for (let i = startMonth; i < 12; i++) {
        newMonthlyValues[i] = 0;
    }

    function distributeAmount(amount, months) {
        if (months.length === 0) return;
        const amountToDistribute = Math.max(0, amount);
        const monthlyAmount = Math.floor(amountToDistribute / months.length);
        let distributed = 0;
        for (let i = 0; i < months.length - 1; i++) {
            const monthIndex = months[i];
            newMonthlyValues[monthIndex] = monthlyAmount;
            distributed += monthlyAmount;
        }
        const lastMonthIndex = months[months.length - 1];
        const remainder = amountToDistribute - distributed;
        newMonthlyValues[lastMonthIndex] = remainder;
    }

    // Update allocation based on type
    switch(type) {
        case 'straight-line':
            distributeAmount(remainingTotal, getAvailableMonths(startMonth, 11));
            break;
        case 'q1':
            distributeAmount(remainingTotal, getAvailableMonths(0, 2));
            break;
        case 'q2':
            distributeAmount(remainingTotal, getAvailableMonths(3, 5));
            break;
        case 'q3':
            distributeAmount(remainingTotal, getAvailableMonths(6, 8));
            break;
        case 'q4':
            distributeAmount(remainingTotal, getAvailableMonths(9, 11));
            break;
        case 'first-half':
            distributeAmount(remainingTotal, getAvailableMonths(0, 5));
            break;
        case 'second-half':
            distributeAmount(remainingTotal, getAvailableMonths(6, 11));
            break;
    }

    expenseData.monthlyValues = newMonthlyValues;

    const inputs = line.querySelectorAll('input.monthly-input');
    newMonthlyValues.forEach((value, index) => {
        if (inputs[index]) {
            inputs[index].value = formatCurrency(value, currentCurrency);
        }
    });

    const totalCell = line.querySelector('.total-value:last-child');
    const spendToDateCell = line.querySelector('.spend-to-date');
    
    if (spendToDateCell) {
        spendToDateCell.textContent = formatCurrency(spendToDate, currentCurrency);
    }
    
    updateLineTotal(expenseData, totalCell);
    updateTotals();
}

function getAvailableMonths(start, end) {
    // Find last month with actuals across all accounts
    let lastActualMonth = -1;
    flexibleExpensesData.forEach(exp => {
        if (exp.actualMonthlyValues) {
            exp.actualMonthlyValues.forEach((value, idx) => {
                if (value !== null && value !== undefined) {
                    lastActualMonth = Math.max(lastActualMonth, idx);
                }
            });
        }
    });

    // Return all months in the range that are after lastActualMonth
    let months = [];
    // Ensure we include end in the range
    for (let i = Math.max(start, lastActualMonth + 1); i <= end; i++) {
        months.push(i);
    }
    return months;
}

function handleMonthlyValue(input, currentValue, currency, onSuccess) {
    let rawValue = input.value.replace(/[^0-9.-]+/g, '');
    
    if (!/^\d+$/.test(rawValue)) {
        alert("Please enter a valid whole number.");
        input.value = formatCurrency(currentValue, currency);
        return false;
    }
    
    const newValue = parseInt(rawValue);
    input.value = formatCurrency(newValue, currency);
    
    if (onSuccess) {
        onSuccess(newValue);
    }
    
    return newValue;
}
function updateLineTotal(expenseData, totalCell) {
    const total = expenseData.monthlyValues.reduce((sum, val) => sum + val, 0);
    totalCell.textContent = formatCurrency(total, currentCurrency);
}

    function createEmployeeBox(employee) {
      const box = document.createElement('div');
      box.className = 'employee-box';
      box.dataset.employeeId = employee.id;

      // Employee header section
      //const header = document.createElement('div');
      //header.className = 'employee-header';

      //const title = document.createElement('h3');
      //title.textContent = employee.name;
      //header.appendChild(title);



      //box.appendChild(header);

      // Employee info section
      const info = document.createElement('div');
      info.className = 'employee-info';

      // Name field
      const nameGroup = document.createElement('div');
      nameGroup.className = 'field-group';
      const nameLabel = document.createElement('label');
      nameLabel.textContent = 'Employee Name';
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = employee.name;
      nameInput.disabled = employee.isExisting;
      nameInput.addEventListener('change', e => updateEmployeeField(employee.id, 'name', e.target.value));
      nameGroup.appendChild(nameLabel);
      nameGroup.appendChild(nameInput);
      info.appendChild(nameGroup);

      // Job Title field
      const titleGroup = document.createElement('div');
      titleGroup.className = 'field-group';
      const titleLabel = document.createElement('label');
      titleLabel.textContent = 'Job Title';
      const titleInput = document.createElement('input');
      titleInput.type = 'text';
      titleInput.value = employee.jobTitle;
      titleInput.addEventListener('change', e => updateEmployeeField(employee.id, 'jobTitle', e.target.value));
      titleGroup.appendChild(titleLabel);
      titleGroup.appendChild(titleInput);
      info.appendChild(titleGroup);

      // SalaryOld field
      const oldsalaryGroup = document.createElement('div');
      oldsalaryGroup.className = 'field-group';
      const oldsalaryLabel = document.createElement('label');
      oldsalaryLabel.textContent = 'Current Annual Salary';
      const oldsalaryDisplay = document.createElement('div'); // Changed to div
      if (employee.isExisting == true) { oldsalaryDisplay.textContent = formatCurrency(employee.salaryOld, employee.currency); }
      else { oldsalaryDisplay.textContent = 'N/A' };

      oldsalaryGroup.appendChild(oldsalaryLabel);
      oldsalaryGroup.appendChild(oldsalaryDisplay); // Append the div
      info.appendChild(oldsalaryGroup);

      // Salary field
      const salaryGroup = document.createElement('div');
      salaryGroup.className = 'field-group';
      const salaryLabel = document.createElement('label');
      salaryLabel.textContent = 'New Annual Salary';
      const salaryInput = document.createElement('input');
      salaryInput.type = 'text';
      salaryInput.value = formatCurrency(employee.salary, employee.currency);
      salaryInput.addEventListener('change', e => {
        // Get the raw input value, remove non-numeric characters (except dots)
        let rawValue = e.target.value.replace(/[^0-9.]/g, '');

        // Validate if the value is a whole number
        if (!/^\d+$/.test(rawValue)) {  // Check if the value is a whole number
          alert("Please enter a valid whole number.");
          e.target.value = previousValue; // Reset to the previous valid value
        } else {
          // If valid, format and update the input
          e.target.value = formatCurrency(parseInt(rawValue), employee.currency);

          // Remove commas and $ sign before passing to updateSalary
          let cleanValue = e.target.value.replace(/[^0-9.]/g, ''); // Remove any commas and $ sign
          updateSalary(employee.id, parseFloat(cleanValue), employee.salaryOld, employee.salaryChangeMonth, employee.currency);

          // Update the previous value to the current valid value
          previousValue = e.target.value; // Save the newly formatted value
        }
      });

      salaryGroup.appendChild(salaryLabel);
      salaryGroup.appendChild(salaryInput);
      info.appendChild(salaryGroup);


      // Month of Salary Change
      const salarychangeGroup = document.createElement('div');
      salarychangeGroup.className = 'field-group';
      const salarychangeLabel = document.createElement('label');
      if (employee.isExisting == true) { salarychangeLabel.textContent = 'Month of Salary Change'; }
      else { salarychangeLabel.textContent = 'Month of Hire'; }
      const salarychangeInput = document.createElement('select');
      salarychangeInput.className = 'salary-change-month';
      salarychangeInput.addEventListener('change', e => {

        updateSalary(employee.id, employee.salary, employee.salaryOld, e.target.value, employee.currency);

      });

      const months = [
        { value: 0, label: 'July' },
        { value: 1, label: 'August' },
        { value: 2, label: 'September' },
        { value: 3, label: 'October' },
        { value: 4, label: 'November' },
        { value: 5, label: 'December' },
        { value: 6, label: 'January' },
        { value: 7, label: 'February' },
        { value: 8, label: 'March' },
        { value: 9, label: 'April' },
        { value: 10, label: 'May' },
        { value: 11, label: 'June' }
      ];

      months.forEach(month => {
        const option = document.createElement('option');
        option.value = month.value;
        option.textContent = month.label;
        salarychangeInput.appendChild(option);
      });

      salarychangeInput.value = employee.salaryChangeMonth;

      salarychangeGroup.appendChild(salarychangeLabel);
      salarychangeGroup.appendChild(salarychangeInput);
      info.appendChild(salarychangeGroup);


      // Salary Currency Override
      const salaryCurrencyGroup = document.createElement('div');
      salaryCurrencyGroup.className = 'field-group';
      const salaryCurrencyLabel = document.createElement('label');
      salaryCurrencyLabel.textContent = 'Salary Currency';
      const salaryCurrencyInput = document.createElement('select');
      salaryCurrencyInput.className = 'salary-change-currency';
      salaryCurrencyInput.addEventListener('change', e => {

        updateSalary(employee.id, employee.salary, employee.salaryOld, employee.salaryChangeMonth, e.target.value);

      });

      const currencies = [
        { value: 'USD', label: 'USD' },
        { value: 'EUR', label: 'EUR' },
        { value: 'GBP', label: 'GBP' }
      ];

      currencies.forEach(currency => {
        const option = document.createElement('option');
        option.value = currency.value;
        option.textContent = currency.label;
        salaryCurrencyInput.appendChild(option);
      });

      salaryCurrencyInput.value = employee.currency;

      salaryCurrencyGroup.appendChild(salaryCurrencyLabel);
      salaryCurrencyGroup.appendChild(salaryCurrencyInput);
      info.appendChild(salaryCurrencyGroup);

      // Delete button for new employees only
      if (!employee.isExisting) {
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'danger';
        deleteBtn.textContent = 'Delete Employee';
        deleteBtn.addEventListener('click', () => deleteEmployee(employee.id));
        info.appendChild(deleteBtn);
      }

      box.appendChild(info);

      // Column headers
      const headers = document.createElement('div');
      headers.className = 'column-headers';

      // Create the button
      const addLineBtn = document.createElement('button');
      addLineBtn.textContent = '+';
      addLineBtn.classList.add('add-line');
      // Add event listener before appending
      addLineBtn.addEventListener('click', () => addAllocationLine(employee.id));

      // Append button first
      headers.appendChild(addLineBtn);

      // Create the headers separately and append them one by one
      const columnTitles = [
        'Allocation %', 'Department', '% Core', 'Jul', 'Aug', 'Sep', 'Oct',
        'Nov', 'Dec', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Total' // Added 'Total'
      ];

      columnTitles.forEach(title => {
        const div = document.createElement('div');
        div.textContent = title;
        headers.appendChild(div);
      });

      box.appendChild(headers);

      // Allocation lines
      employee.allocations.forEach(allocation => {
        box.appendChild(createAllocationLine(employee.id, allocation));
      });

      box.appendChild(createGrandTotalRow(employee));

      // New hires justification line
      if (employee.isExisting === false || employee.justification != null) {
        const hireJustificationGroup = document.createElement('div');
        hireJustificationGroup.className = 'allocation-line grand-total-value';


        hireJustificationGroup.className = 'allocation-line justification-value';
        const hireJustificationLabel = document.createElement('label');
        hireJustificationLabel.textContent = 'Justification for hire: ';
        const hireJustificationInput = document.createElement('input');
        hireJustificationInput.type = 'text';
        hireJustificationInput.value = employee.justification;
        hireJustificationGroup.appendChild(hireJustificationLabel);
        hireJustificationGroup.appendChild(hireJustificationInput); // Append the div
        box.appendChild(hireJustificationGroup);
      }



      // Add allocation button
      //const actions = document.createElement('div');
      //actions.className = 'allocation-actions';
      //const addLineBtn = document.createElement('button');
      //addLineBtn.textContent = '+ Add Allocation Line';
      //addLineBtn.addEventListener('click', () => addAllocationLine(employee.id));
      //actions.appendChild(addLineBtn);
      //box.appendChild(actions);

      // Error message container (initially empty)
      const errorMsg = document.createElement('div');
      errorMsg.className = 'error-message';
      errorMsg.id = `error-${employee.id}`;
      box.appendChild(errorMsg);

      return box;
    }

    function createAllocationLine(employeeId, allocation) {
      const line = document.createElement('div'); 0
      line.className = 'allocation-line';
      line.dataset.allocationId = allocation.id;

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-line';
      deleteBtn.innerHTML = '&times;';
      deleteBtn.addEventListener('click', () => deleteAllocationLine(employeeId, allocation.id));
      line.appendChild(deleteBtn);

      // Allocation percentage
      const percentInput = document.createElement('input');
      percentInput.type = 'text';
      percentInput.min = 0;
      percentInput.max = 100;
      percentInput.value = allocation.percent + '%';
      percentInput.addEventListener('change', e => {
        let value = parseFloat(e.target.value.replace(/[^0-9.]/g, ''));

        // Validate if the value is between 0 and 100
        if (value >= 0 && value <= 100) {
          // If valid, update the value and proceed with the logic
          previousValue = e.target.value; // Update the previous value with the valid one
          updateAllocationPercent(employeeId, allocation.id, parseFloat(e.target.value))
        } else {
          alert('Please enter a value between 0 and 100.');
          // Reset to the previous valid value
          e.target.value = previousValue + '%';
        }
      });
      line.appendChild(percentInput);

      // Department dropdown
      const deptSelect = document.createElement('select');
      departments.forEach(dept => {
        const option = document.createElement('option');
        option.value = dept.value;
        option.textContent = dept.label;
        if (dept.value === allocation.department) {
          option.selected = true;
        }
        deptSelect.appendChild(option);
      });
      deptSelect.addEventListener('change', e =>
        updateAllocationField(employeeId, allocation.id, 'department', e.target.value)
      );
      line.appendChild(deptSelect);

      // Core Allocation percentage
      const percentCoreInput = document.createElement('input');
      percentCoreInput.type = 'text';
      percentCoreInput.min = 0;
      percentCoreInput.max = 100;
      percentCoreInput.value = allocation.percentCore + '%';

      percentCoreInput.addEventListener('change', e => {
        let value = parseFloat(e.target.value.replace(/[^0-9.]/g, ''));

        // Validate if the value is between 0 and 100
        if (value >= 0 && value <= 100) {
          updateAllocationField(employeeId, allocation.id, 'percentCore', value);

          // Format the input
          e.target.value = value + '%';

          // Update totals to reflect the new percentCore value
          updateTotals();

          // Optional: validate the employee
          //validateEmployee(employeeId);

        } else {
          alert('Please enter a value between 0 and 100.');
          // Reset to the previous valid value
          e.target.value = allocation.percentCore + '%';
        }
      });
      line.appendChild(percentCoreInput);

      // Monthly values
      allocation.monthlyValues.forEach((value, index) => {
        const monthInput = document.createElement('input');
        monthInput.type = 'text';
        monthInput.className = 'monthly-input';
        monthInput.value = formatCurrency(value, currentCurrency);
        monthInput.dataset.monthIndex = index;
        monthInput.dataset.originalValue = value; // Store original value for validation
        line.appendChild(monthInput);
      });
      // Calculate and display the total of monthly values
      const totalValue = allocation.monthlyValues.reduce((sum, val) => sum + val, 0);
      const totalCell = document.createElement('div');
      totalCell.className = 'monthly-input total-value';
      totalCell.textContent = formatCurrency(totalValue, currentCurrency);
      totalCell.id = `linetotal-${allocation.id}`; // Unique ID using allocation.id
      line.appendChild(totalCell);

      return line;
    }

    function addNewEmployee() {
      const newEmployee = {
        id: Date.now(), // Use timestamp as temporary ID
        name: 'New Employee',
        jobTitle: 'Job Title',
        salary: 0,
        salaryOld: 0,
        salaryChangeMonth: 0,
        currency: currentCurrency,
        homeDepartment: currentDepartment,
        isExisting: false,
        justification: '',
        allocations: [
          {
            id: Date.now() + 1, // Another temporary ID
            department: currentDepartment,
            percent: 100,
            percentCore: 100,
            monthlyValues: Array(12).fill(0)
          }
        ]
      };

      employeeData.push(newEmployee);
      renderEmployees();
      updateTotals();
      validateAllEmployees();
    }

    function deleteEmployee(employeeId) {
      if (confirm('Are you sure you want to delete this employee?')) {
        employeeData = employeeData.filter(employee => employee.id !== employeeId);
        renderEmployees();
        updateTotals();
        validateAllEmployees();
      }
    }

    function addAllocationLine(employeeId) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      const newAllocation = {
        id: Date.now(), // Use timestamp as temporary ID
        department: currentDepartment,
        percent: 0,
        percentCore: 100,
        monthlyValues: generateMonthlyValues(employee.salary, employee.salaryOld, employee.salaryChangeMonth, 0, employee.currency)
      };

      employee.allocations.push(newAllocation);
      renderEmployees();
      validateAllEmployees();
    }

    function deleteAllocationLine(employeeId, allocationId) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      if (employee.allocations.length <= 1) {
        alert('Cannot delete the last allocation line. Every employee must have at least one allocation.');
        return;
      }

      employee.allocations = employee.allocations.filter(allocation => allocation.id !== allocationId);
      renderEmployees();
      validateAllEmployees();
      updateTotals();
    }

    function updateEmployeeField(employeeId, field, value) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      employee[field] = value;
    }

    function updateSalary(employeeId, newSalary, salaryOld, salaryChangeMonth, currency) {
      const employee = findEmployee(employeeId);

      if (!employee) return;

      employee.currency = currency;
      employee.salary = newSalary;
      employee.salaryChangeMonth = salaryChangeMonth;
      //alert(salaryChangeMonth);

      // Update all allocation monthly values
      employee.allocations.forEach(allocation => {
        allocation.monthlyValues = generateMonthlyValues(newSalary, salaryOld, salaryChangeMonth, allocation.percent, currency);
      });

      renderEmployees();
      updateTotals();
      validateAllEmployees();
    }

    function updateAllocationField(employeeId, allocationId, field, value) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      const allocation = employee.allocations.find(a => a.id === allocationId);
      if (!allocation) return;

      allocation[field] = value;

      // If changing department, may need to update totals
      updateTotals();
      validateAllEmployees();
    }

    function updateAllocationPercent(employeeId, allocationId, newPercent) {
      const employee = findEmployee(employeeId);
      if (!employee) return;

      const allocation = employee.allocations.find(a => a.id === allocationId);
      if (!allocation) return;

      allocation.percent = newPercent;
      allocation.monthlyValues = generateMonthlyValues(employee.salary, employee.salaryOld, employee.salaryChangeMonth, newPercent, employee.currency)

      renderEmployees();
      validateAllEmployees();
      updateTotals();
    }

    function validateEmployee(employee) {
      // Check if total allocation is not 100%
      const totalPercent = employee.allocations.reduce((sum, allocation) =>
        sum + allocation.percent, 0);

      //const totalAllocatedValue = employee.allocations.reduce((sum, allocation) => {
      // Check if allocation.monthlyValues is an array and is defined
      // if (Array.isArray(allocation.monthlyValues)) {
      //   const allocationTotal = allocation.monthlyValues.reduce((subSum, value) => subSum + value, 0);
      //   return sum + allocationTotal; // Add the allocation total to the main sum
      // } else {
      //   // If monthlyValues is not an array or is undefined, skip this allocation
      //   return sum;
      // }
      //}, 0);
      const errorElement = document.getElementById(`error-${employee.id}`);
      const employeeBox = document.querySelector(`.employee-box[data-employee-id="${employee.id}"]`);

      errorElement.textContent = '';

      if (totalPercent != 100) {
        errorElement.textContent += 'Allocations must total to 100%.';
        employeeBox.classList.add('error');
        return false;
        console.log()
      }
      //Allow for small rounding differences (e.g., $11 difference in a $100,000 salary)
      //const roundingTolerance = Math.max(12, Math.round(employee.salary * 0.0001)); // 0.01% tolerance or at least $12

      //if (totalAllocatedValue - employee.salary > roundingTolerance) {
      //  errorElement.textContent += '  The total of all Monthly values must not be greater than the salary amount.'; employeeBox.classList.add('error');
      //}


      else {
        errorElement.textContent = '';
        employeeBox.classList.remove('error');
        return true;
      }
    }

    function validateAllEmployees() {
      const filteredEmployees = employeeData.filter(employee =>
        employee.homeDepartment === currentDepartment
      );

      let validationErrors = 0;

      filteredEmployees.forEach(employee => {
        if (!validateEmployee(employee)) {
          validationErrors++;
        }
      });

      // Update save button state
      hasValidationErrors = validationErrors > 0;
      const saveBtn = document.getElementById('save-btn');
      saveBtn.disabled = hasValidationErrors;

      // Update validation summary
      const validationSummary = document.getElementById('validation-summary');
      if (hasValidationErrors) {
        validationSummary.textContent = `Please fix ${validationErrors} staff validation error${validationErrors > 1 ? 's' : ''} before saving.`;
      } else {
        validationSummary.textContent = '';
      }

      return !hasValidationErrors;
    }

    function updateTotals() {
      const filteredEmployees = employeeData.filter(employee =>
        employee.homeDepartment === currentDepartment
      );



      // Calculate total allocated to home department
      let totalAllocated = 0;
      let totalSalary = 0;
      filteredEmployees.forEach(employee => {
        let employeeTotal = 0;
        employee.allocations.forEach(allocation => {
          totalSalary += allocation.monthlyValues.reduce((sum, val) => sum + val, 0);
          if (allocation.department === currentDepartment) {
            // Sum the monthly values for each allocation
            const allocationTotal = allocation.monthlyValues.reduce((sum, val) => sum + val, 0);
            totalAllocated += allocationTotal;
          }
          // Update the total for each allocation line
          const totalValue = allocation.monthlyValues.reduce((sum, val) => sum + val, 0);
          const totalCell = document.getElementById(`linetotal-${allocation.id}`);
          if (totalCell) {
            totalCell.textContent = formatCurrency(totalValue, currentCurrency);
          }

          // Add to employee's total
          employeeTotal += totalValue;
        });

        // Update the grand total for the employee
        const grandTotalCell = document.getElementById(`grandtotal-${employee.id}`);
        if (grandTotalCell) {
          grandTotalCell.textContent = `${formatCurrency(employeeTotal, currentCurrency)}`;
        }
      });

       // Update flexible expenses total
  const flexibleTotal = flexibleExpensesData
    .filter(exp => exp.department === currentDepartment)
    .reduce((sum, exp) => sum + exp.monthlyValues.reduce((monthSum, val) => monthSum + val, 0), 0);
  
  const totalFlexibleElement = document.getElementById('total-flexible-expenses');
  if (totalFlexibleElement) {
    totalFlexibleElement.textContent = formatCurrency(flexibleTotal, currentCurrency);
  }

      // Calculate total allocated to core
      let totalCore = 0;
      filteredEmployees.forEach(employee => {
        employee.allocations.forEach(allocation => {
          if (allocation.department === currentDepartment) {
            // Sum the monthly values for each allocation and multiply by percentCore
            const allocationTotal = allocation.monthlyValues.reduce((sum, val) => sum + val, 0);
            totalCore += (allocationTotal * (allocation.percentCore / 100));
          }
        });
      });

      document.getElementById('total-salaries').textContent = formatCurrency(totalSalary, currentCurrency);
      document.getElementById('total-allocated').textContent = formatCurrency(totalAllocated, currentCurrency);
      document.getElementById('total-allocated-core').textContent = formatCurrency(totalCore, currentCurrency);
    }

    function createGrandTotalRow(employee) {
      const grandTotalRow = document.createElement('div');
      grandTotalRow.className = 'allocation-line grand-total-value';

      // Empty cells to align with the structure of allocation lines
      for (let i = 0; i < 16; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.textContent = ''; // Keeps the structure aligned
        grandTotalRow.appendChild(emptyCell);
      }

      // Calculate the grand total of all allocations
      const grandTotalValue = employee.allocations.reduce((sum, allocation) => {
        return sum + allocation.monthlyValues.reduce((subSum, val) => subSum + val, 0);
      }, 0);

      // Grand total cell
      const grandTotalCell = document.createElement('div');
      grandTotalCell.textContent = formatCurrency(grandTotalValue, currentCurrency);
      grandTotalCell.id = `grandtotal-${employee.id}`;
      grandTotalRow.appendChild(grandTotalCell);

      return grandTotalRow;
    }

    

    function saveData() {
      if (hasValidationErrors) {
        alert('Please fix all validation errors before saving.');
        return;
      }

      // Find current iteration and update its employee data
      const iterationIndex = budgetData.iterations.findIndex(iter => iter.iterationId === currentIteration);
      if (iterationIndex === -1) {
        alert('Cannot find the current iteration to save.');
        return;
      }
      // Update the employee and account data in the budget data structure
      budgetData.iterations[iterationIndex].employees = employeeData;

      budgetData.iterations[iterationIndex].flexibleExpenses = flexibleExpensesData;

      // In a real application, this would post data to an API endpoint
      const dataToSave = {
        iterationId: currentIteration,
        timestamp: new Date().toISOString(),
        employees: employeeData,
        flexibleExpenses: flexibleExpensesData
      };

      // Simulate API call
      console.log('Saving data:', dataToSave);
      alert(`Data for iteration ${currentIteration} saved successfully.`);
    }

    // Helper functions
    function findEmployee(id) {
      return employeeData.find(employee => employee.id === id);
    }

    function generateMonthlyValues(newSalary, salaryOld, salaryChangeMonth, percent, currency) {
    if (currentCurrency != currency) {
        const fx_rate = fx_rates.find(rate => rate.from === currency && rate.to === currentCurrency);
        newSalary = newSalary * fx_rate.rate;
        salaryOld = salaryOld * fx_rate.rate;
    }

    const totalAmountold = salaryOld * (percent / 100);
    const totalAmountNew = newSalary * (percent / 100);
    const baseMonthlyAmountOld = totalAmountold / 12;
    const baseMonthlyAmountNew = totalAmountNew / 12;
    const roundedValues = []; // Initialize empty array
    let sumNewValues = 0;

    // Use standard array assignment
    for (let i = 0; i < 11; i++) {
        if (i < salaryChangeMonth) {
            roundedValues[i] = Math.round(baseMonthlyAmountOld);
        } else {
            roundedValues[i] = Math.round(baseMonthlyAmountNew);
            sumNewValues += Math.round(baseMonthlyAmountNew);
        }
    }

    // Add the final month
    roundedValues[11] = Math.round(baseMonthlyAmountNew * (12 - salaryChangeMonth)) - sumNewValues;

    return roundedValues;
}

    function formatCurrency(amount, currency) {
      const numberFormat = new Intl.NumberFormat();
      switch (currency || 'USD') {
        case 'USD':
          return '$' + numberFormat.format(amount);
        case 'GBP':
          return '£' + numberFormat.format(amount); // Use the correct GBP symbol
        case 'EUR':
          return '€' + numberFormat.format(amount); // Use the correct EUR symbol      
        default:
          return numberFormat.format(amount); // Just format the number if no currency is set
      }
    }

    function displayCurrency() {
      //const department = departments.find(dept => dept.value === currentDepartment);
      const currencyDisplay = document.getElementById('currency-display');
      currencyDisplay.innerHTML = 'This department is budgeting in: <span class="bold-currency">' + currentCurrency + '</span>';
    }


  });
</script>
</body>

</html>